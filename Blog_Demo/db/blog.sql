/*
 Navicat Premium Data Transfer

 Source Server         : myData
 Source Server Type    : MySQL
 Source Server Version : 50735
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50735
 File Encoding         : 65001

 Date: 22/07/2022 23:10:13
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for admin_user
-- ----------------------------
DROP TABLE IF EXISTS `admin_user`;
CREATE TABLE `admin_user`  (
  `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '管理员id',
  `user_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户名',
  `user_password` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码',
  `nick_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '昵称',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '是否锁定 0未锁定 1已锁定无法登陆',
  `roles` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'user' COMMENT '用户角色/权限',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '/avatar/img.png' COMMENT '用户头像',
  PRIMARY KEY (`user_id`) USING BTREE,
  UNIQUE INDEX `user_name`(`user_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 107 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of admin_user
-- ----------------------------
INSERT INTO `admin_user` VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', '十八', '0', 'admin', '/avatar/220716-215201-1657979521605.jpg');
INSERT INTO `admin_user` VALUES (2, 'user', 'e10adc3949ba59abbe56e057f20f883e', 'user', '0', 'boss', '/avatar/img.png');
INSERT INTO `admin_user` VALUES (48, '测试', 'e10adc3949ba59abbe56e057f20f883e', '游客', '1', 'user', '/avatar/img.png');
INSERT INTO `admin_user` VALUES (106, '游客', 'e10adc3949ba59abbe56e057f20f883e', '游客', '0', 'user', '/avatar/img.png');

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `blog_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '博客表主键id',
  `blog_title` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客标题',
  `blog_content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客内容',
  `blog_cate` varchar(18) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '博客类别',
  `blog_tag_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客标签名，空格 分隔字符串',
  `blog_status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '1' COMMENT '0-草稿 1-发布，默认 1',
  `blog_views` bigint(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '浏览量',
  `allow_comm` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '0-允许评论 1-不允许评论',
  `deleted` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `comment_num` int(11) NOT NULL DEFAULT 0 COMMENT '评论数量',
  PRIMARY KEY (`blog_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (5, '预习', '## Java学习准备工作\n---\n[TOCM]\n\n---\n\n### 常用快捷键\n\nCtrl + A：全选	Ctrl + C：赋值\n\nCtrl + X：剪切	Ctrl + V：粘贴\n\nCtrl + Z：撤销	Ctrl + S：保存\n\nAlt + F4：关闭窗口\n\nShift + delete：永久删除\n\nWin + R：命令窗口\n\nWin + Shift +S:：截图\n\nWin + V：剪切板\n\nWin + L：锁屏\n\nWin + I：系统设置\n\nWin + E：我的电脑\n\nWin + Tab：切换桌面\n\nCtrl + Shift + Esc：任务管理器\n\nWin + R（Explore）：找回桌面\n\n### Java DOS\n\n#### 常用DOS命令\n\n1. 开始--系统--命令提示符\n2. Win + R （cmd）回车\n3. 任意文件夹Shift + 鼠标右键；命令提示符\n4. 资源管理器地址栏前加cmd路径\n\n管理员方式运行：右键选择管理员方式运行获取最高权限\n\n#### DOS命令\n\n```cmd\n#右键粘贴\n#table 可以补全文件名\nD:			#盘符切换\ndir 		#当前目录下的所有文件\ncd + 文件名  #切换目录（change directory）\ncd 文件名\\文件名 # 切换多级目录\ncd.. 		#返回上一级目录\ncd\\			#返回根目录\ncls 		#清理屏幕（Clear screen）\nexit 		#退出终端\nipconfig	#查看电脑IP\n#打开应用\ncalc   		#计算器\nmspaint		#画图\nnotpad\nping + 网址 #ping命令\n#文件操作\nmd + 目录名			#创建文件夹\ncd> + 文件名.格式		#创建文件\ndel	+ 文件名.格式		#删除文件\nrd + 目录名	#移除目录（remove directory）\n```\n\n### MarkDown\n\n==一级标题==：`== text ==` 高亮\n\n~~~markdown\n一级标题\n===\n二级标题\n---\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n==一级标题==：`== text ==` 高亮\n\n换行<br/>显示，使用 html 标签换行\n\n双星号**加粗**，单个星号*斜体*，三星号***斜体加粗***\n双下划线__强调__，单下划线_斜体_，三下划线___斜体加粗___\n\n1. 有序列表\n3. 数字无需顺序\n\n- 无序列表\n- 需要空格\n	- 缩进以换层级\n	* 无需列表\n	+ 无序列表\n\n> ## 块引用，标题\n>\n> - 列表\n>>嵌套块\n>>>包含其他元素 **加粗**，*斜体*\n\n反引号：`代码格式`\n``转移双反引号嵌套`反引号` ``\n\n分隔线：三个以上连续下列符号\n****\n----\n____\n\n链接 [链接文本](链接地址 \"链接title，鼠标悬停提示\")\n\n<网址>\n<Email>\n![这是图片](/assets/img/philly-magic-garden.jpg \"Magic Gardens\")\n\n<span></span>\n\n<a src=\"可以直接使用html语法\"></a>\n\n|文本 | 标题 |：表格\n\n``` 代码块 ```\n~~~  删除线   ~~~\n```java Java代码框\n~~~js   js代码框 ~~~在 Typora 中生效\n~~~\n\n>块文件\n>\n>\n>\n>空一行继续\n>\n>> - 列表\n>\n>>嵌套块\n>\n>>>包含其他元素 **加粗**，*斜体*\n\n\n\n1. 列表，空一格\n\n2. - 无序列表\n\n     - 缩进以层进\n\n     > 缩进块引用\n\n3. 嵌套\n\n4. -\n\n分割线 `****`、`----`、`____`\n\n****\n\n----\n\n____\n\n`[](\"Markdown学习\")：链接` [Markdown语法](https://markdown.com.cn \"链接title，鼠标悬停提示\")\n\n`<url>：网址` https://www.baidu.com\n\n`<email>：email`<2217794007@qq.com>\n\n`![图片alt](图片链接 \"图片title\")：`![图片](/assets/img/philly-magic-garden.jpg \"图片标题\")\n\n<span></span>\n\n<a src=\"可以直接使用html语法\"></a>\n\n`|文本 | 标题 |：表格`\n\n| 文本 | 标题 |\n| ---- | ---- |\n|   示例   | 内容 |\n\n\n` `````` `\n\n``` 代码块 范围内，都可以使用代码```\n\n`[^脚注]：` [^脚注]\n\n`## 标题编号 {#2}：`\n\n\n\n### Java版本\n\nJavaSE：标准版\n\nJavaME：嵌入式开发（基本无用）\n\nJavaEE：企业级应用开发\n\n### Java配置环境\n\nJDK：Java Development Kit（包含JRE和JVM）\n\nJRE：Java Runtime Environment\n\nJVM：Java Virtual Machine（跨平台核心，虚拟机）\n\n- JDK = JRE + Java开发工具\n- JRE = JVM + Java核心类库\n\n### JDK卸载与安装\n\n#### 卸载\n\n1. 删除安装目录\n2. 删除环境变量（JAVA_HONE，PATH）\n3. java -version查询\n\n#### 安装\n\n1. 查找JDK下载版本（一般不用最新版）\n\n2. 安装（配置路径）\n\n3. 配置环境变量\n\n   1. JAVA_HOME：JDK包路径\n\n   2. PATH：%JAVA_HOME%\\bin\n\n      (%JAVA_NOME%\\jie\\bin)\n\n#### 测试\n\nDOS命令\n\n##### java -version\n\nJava版本查询\n\n##### javac\n\n编译`.java`文件为`.class`文件\n\n##### java\n\n运行`.class`文件', '预习', '预习 基础 学习', '1', 26, '1', '0', '2022-04-16 22:11:03', '2022-07-17 18:03:25', 0);
INSERT INTO `blog` VALUES (7, '毕设需求文档', '### 功能需求\n---\n[TOCM]\n\n[TOC]\n\n---\n\n\n1. 注册账号\n2. 登录账号\n3. 看书：根据不同状态\n   - 登录状态\n     - 查找\n     - 下载\n     - 上传\n     - 点赞\n     - 评论\n     - 收藏\n     - 加书架\n   - 非登陆状态\n     - 只能搜书、在线看书\n     - 不能添加到书架以及使用其他功能\n   - 看书\n     - 按章节显示，可查看章节目录\n     - 点击章节目录跳转章节\n     - 上一章、下一章\n\n- 查找：根据书名或作者查找\n- 下载：下载文本文件到本地\n- 上传：上传文本文件到数据库\n- 点赞：本人可取消\n- 评论：不能回复，可以点赞，作者和本人可以删除\n- 书架：放书\n  - 添加书籍，书架保存的书，阅读退出后自动保存当前阅读进度\n  - 删除书籍，自由选择删除\n- 推荐：推荐量增加，不可取消，主页按照推荐量排序\n\n所有功能用网页展示，实现交互\n\n### 数据库表\n\nbook：书籍\n\n- id：主键\n- name：书名\n- author：作者\n- cover：封面\n- info：简介\n- type：类型\n- status：状态（连载，完结）\n- creattime：添加时间\n- votes：投票\n- content：内容\n\nuser：用户\n\n- id：用户 id\n- username：用户名\n- password：密码\n- nickname：昵称\n- role：角色（对应账号权限）\n- status：账号状态\n\nbookshelf：阅读记录\n\n- id：记录 id\n- userid：用户 id\n- bookname：书架书籍\n- title：最后阅读章节名\n\n\n\n非登录状态下：书籍浏览功能、推荐、搜索功能、定向查找功能、友情链接，、还包括注册、登录模块；\n\n登录状态下还拥有账号信息展示、书架管理、投票、个人信息管理、登出、下载功能、文件上传等功能。', '随笔', '小说 Novel', '1', 3, '0', '1', '2022-04-18 21:40:01', '2022-05-25 20:47:54', 0);
INSERT INTO `blog` VALUES (8, '基础', '## Java简单基础\n---\n[TOCM]\n\n---\n\n### Java程序机制\n\n- 编译型\n- 解释型\n\n把`.java`文件编译为`.class`字节文件，再运行`.class`文件\n\n### 进制\n\n十进制\n\n- 转其他进制，除要转的进制数，余数相连\n\n二进制：0b\n\n- 转十进制：每位*2^位-1^，再依次相加\n\n- 转八进制：从右至左三位一组转为十进制数即为八进制\n- 转十六进制：从右至左四位一组转为十进制数即为十六进制\n\n八进制：0\n\n- 转十进制：每位*8^位-1^，再依次相加\n- 转二进制：每位转为三位二进制数\n\n十六进制：0x\n\n0-9 A-F\n\n- 每位*16^位-1^，再依次相加\n- 转二进制：每位转为四位二进制数\n\n```java\nint a = 0b10011;\nint b = 010;\nint c = 10;\nint d = 0x10;\nSystem.out.printf(\"%d,%d,%d,%d%n\",a,b,c,d);\n输出结果：19,8,10,16\n```\n\n### 原码、补码、反码\n\n二进制最高位为符号位，0为 +，1为 -\n\n1. 正数三码合一（都一样）\n2. 负数反码为符号位不变，其他按位取反；补码为反码+1\n3. 0 反码、补码都为0\n4. Java没有无符号数\n5. 计算机运算时**以补码方式运算**，但看结果时看原码\n\n### 类型转换优先级 \n\nchar、byte、short→int→long→float→double\n\n注意数据类型精度\n\nchar、byte、short参与运算后直接转为int类类型，无论与谁运算\n\nJava是强类型语言，每个变量都必须声明类型，在使用时必须初始化\n\n### 位运算\n\n```java\n&：按位与，同1为1，不同为0\n|：按位或，有1为1，无1为0\n^：按位异或，相同为0，不同为1\n~：取反\n<<：左移*2\n>>：右移/2\n```\n\n注意：\n\n```java\nint a = 1;\nint b = 1;\nSystem.out.println(\" \" + a + b);\nSystem.out.println(a + b + \" ;\");\n输出结果：\n 11\n2 ; \n```\n\n### 包名规范\n\n公司域名倒写 + 项目名\n\n例如：com.baidu.demo\n\n`.*`为通配符，导入该包内所有文件\n\n### javaDoc\n\n@author 作者\n\n@version 版本号\n\n@since 指明需要最早使用的JDK版本\n\n@param 参数名\n\n@return 返回值\n\n@throws 可能抛出异常\n\n### 方法\n\n- 语句的集合，在一起执行一个功能\n- 解决一类问题的步骤的有序组合\n\n#### 设计原则\n\n原子性：一个方法只完成一个功能，利于后期扩展\n\n### 传递\n\n- Java 基本数据类型传递参数时是值传递\n  - 传递数值的副本，对原数据无影响 \n- 引用类型传递参数时是引用传递\n  - 引用 z = null 只是将引用z不指向任何对象 ，并不会对原先指向的对象数据进行修改 。\n\n### 递归\n\n方法自身调用自身\n\n- 递归头：有结束调用的时候，若没有会陷入死循环\n- 递归体：调用自身方法的时候\n\n连续调用→边界结束→值返回\n\n缺点：深度越大时空复杂度越高；对性能要求很高\n\n### Java内存\n\n- 堆：存放new的对象和数组\n  - 被所有线程共享，不会存放别的对象引用	\n- 栈：\n  - 存放基本变量类型：包含数值\n  - 引用对象的变量：在堆中的地址\n- 方法区\n  - 可被所有线程共享，包含所有class和static变量\n\n### 数组\n\n相同类型数据的有序集合（任意类型）\n\n数组也是对象，数组元素相当于对象的成员变量，存放在堆中\n\n长度确定，不可变 \n\n#### 稀疏数组\n\n原始数组：\n1	0	0	0	0	0	0	0	0	0	\n0	1	0	0	0	0	0	0	0	0	\n0	0	1	0	0	0	0	0	0	0	\n0	0	0	0	0	0	0	0	0	0	\n0	0	0	0	0	0	0	0	0	0	\n0	0	0	0	0	0	0	0	0	0	\n0	0	0	0	0	0	0	0	0	0	\n0	0	0	0	0	0	0	0	0	0	\n0	0	0	0	0	0	0	0	0	0	\n0	0	0	0	0	0	0	0	0	0	\n转化为稀疏数组\n10	10	3	//行坐标  列坐标  总值数\n0	0	1		//例如：`array[0][0]` = 1\n1	1	1	\n2	2	1\n\n##### 转化为稀疏数组注意：\n\n1. 找到原数组中所有的值个数，加一为转化数组的行数；转化数组恒定为3列\n\n   - ```java\n     int values = 0;\n     for (int[] a : array) {\n         for (int b : a){\n             if (b != 0)\n                 values++; //遍历得到原数组中的值的个数\n         }\n     }\n     int [][] array2 = new int [values+1][3];\n     ```\n\n     \n\n2. 首行信息\n\n   - ```java\n     array2[0][0] = array.length; //原数组行数\n     array2[0][1] = array[0].length;//原数组列数\n     array2[0][2] = values; //原数组值的个数\n     ```\n\n     \n\n3. 遍历原数组所有元素，若 值不为0 则赋值给稀疏数组；注意数组下标\n\n   - ```java\n     int row = 1; //从1开始，因为首行显示总信息\n     array2[row][0] = i; //行坐标\n     array2[row][1] = j; //列坐标\n     array2[row][2] = array[i][j]; //该坐标元素值\n     //坐标格式恒定\n     row++;\n     ```\n\n     \n\n4. 遍历输出数组\n\n   - ```java\n     for (int[] a : array2) {\n         for (int b : a){\n             System.out.print(b + \"\\t\");\n         }\n         System.out.println();\n     }\n     ```\n\n   ##### 还原数组\n\n   ```java\n   //还原为原数组\n   int [][] array3 = new int [array2[0][0]][array2[0][1]];\n   for (int i = 1; i < array2.length; i++){\n   	for (int j = 0; j < array2[i].length; j++){\n   		array3[array2[i][0]][array2[i][1]] = array2[i][j];\n   	}\n   }\n   for (int[] a : array3) {\n   	for (int b : a){\n   		System.out.print(b + \"\\t\");\n   }\n   System.out.println();\n   }\n   ```\n\n   \n\n', 'Java', '基础 预习', '1', 0, '0', '0', '2022-04-19 23:20:00', '2022-07-17 17:55:26', 0);
INSERT INTO `blog` VALUES (9, 'JavaScript', '## JavaScript\n---\n[TOCM]\n\n---\n脚本语言\n\n- ECMAScript\n  - JS 核心语法：ES 规范 / ECMA - 262 标准\n- DOM：Document Object Model；文档对象模型\n  - 对网页中节点进行增删改的过程\n  - HTML 文档被当作一颗 DOM 树看待\n    - `var domObj = document.getElementById(\"id\")`\n- BOM：Browser Object Model；浏览器模型对象\n  - 关闭浏览器、打开浏览器新窗口、后退、前进、地址栏地址等都是 BOM 编程\n- DOM 和 BOM\n  - DOM 顶级对象：document；页面对象\n  - BOM 顶级对象：window，窗口对象\n  - 实际上 BOM 包括 DOM\n\n### ECMAScript\n\n- JS 是事件驱动型语言，依靠事件驱动执行对应程序\n- JS 中有很多事件，事件对应都有事件句柄作为 html 标签属性存在\n- JS 中有内置对象 window 可以直接使用\n  - 代表浏览器对象\n  - window 对象有函数 alert 进行弹窗\n    - `window.alert(”弹窗消息”)`：进行弹窗\n    - window 可以省略\n  - 内置对象 `document`：代表当前 html 页面\n- JS 中字符串可以使用双引号，也可以使用单引号\n- JS 中一条语句结束后可以使用 ; 也可以不用\n\n#### 嵌入 JS\n\n##### 事件\n\nHTML 中嵌入 JS 代码 1：事件\n\n- 鼠标单击事件：click\n  - 对应事件句柄 onclick 作为 html 的标签属性存在\n\n```html\n<body>\n    <input type=\"button\" value=\"0\" onclick=\" 直接写 js 代码\">\n    <input type=\"button\" value=\"1\" onclick=\"window.alter(\"二狗\")\">\n    <input type=\"button\" value=\"2\" onclick=\"alter(\"二狗\")\">\n</body>\n```\n\n- onclick = “js 代码”\n  - 在页面打开的时候 js 代码并不会执行，仅将代码注册到对应事件上\n  - 当 click 事件发生的时候 js 代码自动被浏览器调用\n\n##### 脚本块\n\nHTML 中嵌入 JS 代码 2：脚本块\n\n```html\n<!-- type 类型默认定义是 text/javascript -->\n<script type=\"text/javascript\">\n	//脚本块内部可以写js代码，加载页面时直接执行\n    window.alert(\"二狗\");\n</script>\n```\n\n- 暴露在脚本块中的程序在页面打开的时候执行\n- 遵循自上而下的顺序逐行执行，不需额外事件\n  - alert 函数会阻塞页面加载，确定之后才会继续执行语句\n- 脚本块可以放到页面任何位置，甚至 `<html>`标签之外\n- 脚本快在页面中出现次数没有要求\n\n##### 引入\n\nHTML 中嵌入 JS 代码 3：引入外部独立的 js 文件\n\n```html\n<body>\n	<script tup=\"text/javascript\" src=\"js/1.js\">\n    	//引用文件时写在脚本块中内容不被执行\n    </script> <!-- 此标签不能省略 -->\n    <!-- 可以再单独使用脚本块会被执行 -->\n</body>\n```\n\n- 将 js 代码写到单独文件中，在需要时进行引用\n  - `src=\"js/1.js\"`：外部 js 文件路径\n- 引用外部 js 文件时文件中代码会遵循自上而下顺序依次执行\n  - 同一个文件可以被多次引用，但没有必要\n- 引用是必须是双标签`<script></script>`\n  - 不能是自闭标签\n\n#### 标识符\n\n- 标识符命名规范：按照 Java 标准\n  - 字母、数字、下划线、$\n  - 不能以 数字开头\n  - 不能使用 关键字 命名\n  - 驼峰命名，见名知意\n  - 常量名全部大写，单词之间下划线分隔\n\n#### 变量\n\n- JavaScript 是弱类型语言\n  - Java 是强类型语言：变量数据类型在编译时已经确定，不可变\n    - 强制类型转换只是在语法层面改变\n- 声明变量：`var 变量名 = 值`\n  - 无编译阶段，变量可以随意赋值，赋值任意类型\n  - `undefined`：在 js 中是一个 具体存在的值\n    - 变量仅声明未赋值：默认值`undefined`\n    - 变量未声明时不能使用\n  - 可以同时声明多个变量，使用时无要求\n\n```html\n<body>\n	<script type=\"text/javascript\">\n        \'use strict\'  //启用严格检查模式，不允许未定义变量直接使用\n        //默认赋值 i = undefined\n        var i;  //定义变量 i，可以重新使用 i 定义变量\n        let a;  //定义变量，不允许重新定义变量 a\n        const B = 23;   //定义常量 B，不允许重新赋值\n        alert(\"i = \" + i);\n        var a, b, c; //声明变量\n	</script>\n</body>\n```\n\n局部变量 和 全局变量\n\n- 全局变量：函数体之外声明\n  - 生命周期：浏览器打开时声明，关闭时销毁\n  - 尽量少用，会在浏览器内存中一直存在，耗费内存空间\n- 局部变量：函数体之内声明，包括函数的形参\n  - 生命周期：函数开始执行是开辟内存空间，执行结束后释放空间\n  - 生命周期较短\n- 变量声明时若没有 var 则必定是全局变量\n  - 全局变量默认绑定在 window 上\n  - 无论在哪里声明\n\n##### 严格模式\n\n- `\'use strict\'`\n\n  - 启用严格检查模式，不允许未定义变量直接使用\n  - 语法检测按照 ES6 标准更加严格\n  - 写在 `script` 脚本块中第一行\n\n- 所有的全局变量都会绑定到 window\n\n  - 当不同的 js 文件使用相同的全局变量时会发生冲突\n\n  - 解决：定义唯一全局变量 `var onlyOne = {}`\n\n    - 将所有全局变量都绑定到其上面\n\n```js\n    const onlyOne = {}  //定义唯一全局变量\n    onlyOne.name = \"张三\";  //将其他全局变量绑定到 onlyOne\n    //将所有代码都放到自定义命名空间 onlyOne 中\n```\n\n- 局部作用域：`let` 定义局部变量，ES 6 引入\n\n  - 解决局部作用域冲突的问题\n  - 不能重新定义同名变量\n\n- 常量定义：`const`，ES 6 引入\n\n#### 数据类型\n\n- JS 中变量没有数据类型，但是赋值的时候有数据类型\n- 分为 原始类型 和 引用类型\n  - ES6 之前有6种，ES6 有 7 种\n    - ES：ECMAScript 规范\n  - 原始类型：\n    - `Null`\n      - 只有值 null\n    - `Undefined`\n      - 只有一个值 undefined\n        - null 和 undefined 可以等同\n      - 变量未赋值时默认赋值，或手动赋值\n    - `Boolean`\n      - 只有 true、false\n      - `if()`，`while()` 会将参数转为 boolean 类型\n    - `Number`\n      - 包括所有 数值类型 和 NaN，包括 无穷大\n      - `infinity`：无穷大，除数为 0 结果 无穷大\n      - `NaN`\n        - 运算结果本应是数字，但运算完之后不是数字则结果为 NaN\n        - 和所有数字类型都不相等，包括自身\n    - `String`\n      - JS 中字符串可使用 `“”` 或 `‘’`\n      - 转义字符 `\\`\n      - `` 可以写多行\n  - 引用类型\n    - `Object` 及其 子类\n      - 所有类型的超类，自定义类都继承 Object\n      - 包含在其他 JScript 对象中\n        - 其他所有对象中它的方法和属性都可用\n    - ES6 之后又添加一种 `Symbol` \n- JS 中有运算符 `typeof`\n  - 在程序运行阶段动态获取变量的数据类型\n  - 格式：`typeof 变量名 `，运算结果是六个字符串之一（小写）\n    - “undefined”、“number”、“string”、“boolean”\n    - “object”、“function”\n- JS 中比较字符串相等使用 `==`：判断值相等，等同运算符\n  - `alert(1 == true)`：结果 true，1 等同于 true\n- 运算符 `===`：判断值和数据类型相等，全等运算符\n  - `alert(1 === true)`：结果 false，数据类型不同\n\n```js\nvar i = null;  		// Null 类型\nalert(typeof i); 	// 结果是 \"object\"\nfunction say(){}  	// 定义函数\nalert(typeof say) 	// 结果是 \"function\"\n```\n\n##### String\n\n- 创建方式\n  - `var a = “String”`\n    - 称为 小String，原始 String 类型\n  - JS 内置支持类 String：`var a = new String(\"String\")`\n    - 被称为 大String，Object 类型\n- 大小String 函数、属性通用\n- String 是内置支持类，可直接使用，父类是 Object\n\n```js\nlet a = \"aa\";\nlet b = \"bb\";\nlet resutl = `动态拼接\n	${a}${b}`  // 结果：动态拼接aabb；``可以跨行拼接无需 + 拼接\n```\n\n#### Object\n\n- JS 中定义的类默认继承 Object\n  - 会拥有所有 Object 类的属性和函数\n\n属性\n\n- protoType：常用，给类动态扩展属性和函数\n- constructor\n\n函数\n\n- toString()\n- valueOf()\n- toLocaleString()\n\n##### 定义类\n\n- JS 中类的定义同时是构造函数的定义\n  - 类定义和函数定义在一起完成\n  - 可以在函数体内嵌套函数\n- 使用 protoType 属性动态扩展属性及函数\n  - 可以给任何类拓展函数、属性\n    - 包括内置类型\n- 使用 `new`就是将函数当作类使用创建对象\n  - 否则作为函数调用\n\n```js\n//定义类两种方式\nfunction 类名(形参){}\n类名 = function(形参){}\n//创建对象\nnew 构造方法名(实参);  //构造方法名和类名一致\n\n//示例\n//定义类 Demo，或认为是函数 Demo\nfunction Demo(name, age, hobby){\n    this.name = name,\n    this.age = age,\n    this.hobby = hobby,\n    sex = \"男\"\n}\ndemo(\"二狗\", 18); 		 	//将 Demo 作为函数调用\nvar obj = new Demo(\"二狗\");    //将 Demo 作为类创建对象\nalert( obj.name );  	//访问对象属性 .\nalert( obj[\"age\"] );	//访问对象属性 []\n/*\nobj 是一个引用，保存内地址指向堆中的对象\n*/\n//利用 prototype 属性拓展 Demo 类函数：拓展函数 getHobby()\nDemo.prototype.getHobby = function(){\n    return this.hobby;\n};\nvar hobby = obj.getHobby();\nalert(hobby)\n```\n\n##### 对象\n\n```js\n//定义 js 对象\nvar demo = {\n    name: \"张三\",\n    age : 18,\n    sex : \"男\"\n}\ndocument.writeln(demo.age);  // 18\ndelete demo.age  			// 删除 age 属性\ndocument.writeln(demo.age);  // undefined\ndemo.age = 20  				// 添加 age 属性\ndocument.writeln(demo.age);  // 20\ndocument.write(\'age\' in demo) //判断 demo 对象中是否有 age 属性\n```\n\n##### 原型模式\n\n- 以另一个对象作为当前对象原型\n  - 即 继承\n- `prototype`属性即类原型\n- 原型链：所有类的父类总是指向 Object 类\n  - Object 的原型是它自身，无限循环\n\n```js\n//定义 js 对象\nvar demo = {\n    name: \"张三\",\n    age : 18,\n    sex : function (){\n        return this.age > 15 ? \"男\" : \"女\";\n    }\n}\nvar demo2 = {\n    age : 10\n}\n//以 demo 对象为 demo2 的原型\ndemo2._proto_ = demo\nvar sex = demo2.sex\ndocument.write(sex)\n```\n\n##### class\n\n- 继承；ES 6 新增特性\n- 本质上还是使用原型模式\n  - 但是更符合 Java 写法\n\n```js\n//定义类\nclass Demo {\n    //构造函数\n    constructor(name) {\n        this.name = name\n    }\n    //普通函数\n    say(){\n        alert(\"hello\")\n    }\n}\nlet demo = new Demo();  //创建对象\ndemo.say();   //调用方法\n// 类 Demo2 继承 Demo\nclass Demo2 extends Demo{\n    constructor() {\n        super();\n    }\n    hello(){}\n}\nlet demo2 = new Demo2()\n```\n\n#### Map、Set\n\nES6 标准新增，用法跟 Java 相似\n\n- Map：key 不允许重复，重复的 key 会修改前面对应的的 value\n- Set：值不允许重复，重复的值不会添加；无序\n\n```js\nlet map = new Map   		//创建 map\nmap.set(\"name\", \"张三\")  	   //添加元素\nmap.get(\"name\") 			//根据 key 获取元素\nmap.forEach(function (demo){ //遍历map\n    document.writeln(demo)   // demo 是 map 中的 value值\n})\n//for of 遍历 Map，得到 K-V 数组，分别取出\nfor (let mapElement of map) {\n       document.writeln(mapElement[0] +\n               \': \' + mapElement[1] + \"<br/>\")\n   }\ndocument.write(\"<br/>\")\n\nlet set =  new Set 			//创建 set\nset.add(19)					//添加元素\nset.delete(19)				//删除元素\nset.has(19)					//判断是否有元素\nset.forEach(function (value){ //遍历set\n    document.writeln(value + \"<br/>\")  //得到 set 中的元素\n})\n```\n\n#### 函数\n\n- 函数作用等同于 Java 中的方法\n\n  - 可被重复利用的代码片段\n  - 一般用于完成某个特定功能\n\n- 语法格式\n\n  ```js\n  function 函数名(形参列表){ /* 函数体 */ }\n  //或另一种方式\n  函数名 = function(形参列表){ /* 函数体 */ }\n\n  function sum(a, b){\n      // a, b 是局部变量，都是形参，作为变量名随意指定\n  }\n```\n\n- 函数被调用之后才会执行\n\n  - 一般使用事件调用\n\n- 外部调用函数调用需要带 `()`\n\n  - js 内部调用不需要 `()`\n\n- JS 中不需要函数重载：函数不能重名\n\n  - 两个函数同名时后面的函数会覆盖前面的函数\n\n- `apply()`函数可以改变调用此函数的对象（函数内部 this 指向）\n\n##### 形参赋值\n\n1. 传参数量和形参相同按顺序赋值\n\n   - 参数类型无限制\n\n2. 传参数量少于形参，按顺序赋值前面形参，后面赋值 `undefined`\n\n3. 不传参时都赋值 `undefined`\n\n   - 两个`undefined`相加值为 `NaN`\n\n   - `NaN`是一个具体值：表示不是数字\n     - Not a Number\n\n4. 传参数量多于形参，按顺序赋值形参，多余的不计\n\n5. `arguments`关键字代表传到函数中的所有实参\n\n   - 数组类型，包含传进来的所有参数\n   - 包括已定义的参数\n\n6. `reset`参数：定义在形参列表最后面 `function demo(a, b, ...rest){}`\n\n   - 包含传进来的参数中它之前定义元素之外的所有元素\n   - ES 6 新增\n\n参数类型不符合时需要手动抛出异常\n\n```js\nfunction abs(a){\n   if(\'number\' !== typeof a){\n       throw \"not a number\"\n   }\n    return a >= 0 ? a : -a;\n}\n```\n\n\n\n##### 系统函数\n\n部分系统函数\n\n- `alert()`函数：弹窗\n- `isNaN()`函数：判断是否是数字，true 表示是数字\n- `parseInt()`函数：字符串解析为数字，舍弃小数位\n- `paseFloat()`函数：字符串解析为数字，保留小数位\n- `console.log()`：打印到控制台输出\n- `Math.ceil()`函数：向上取整\n  - Math 是数学类\n- `if()`：判断，为 true 执行 if，否则执行 else\n  - 括号内参数只能为 true 或 false\n  - 自动调用 Booelan() 将其他数据类型转为 boolean 类型\n  - 只要内容不为空都是 true\n    - 0、“”、null、NaN、undefined 为false\n    - 只要有就是 true，否则为 false\n\n#### 事件\n\n##### 常用事件\n\n- 焦点\n  - `blur`：失去焦点\n  - `focus`：获得焦点\n- 状态\n  - `change`：下拉表中选中项改变或文本框内容改变\n  - `click`：鼠标单击\n  - `dbclick`：鼠标双击\n- 键鼠操作\n  - `keydown`：键盘按下\n  - `keyup`：键盘弹起\n  - `mousedown`：鼠标按下\n  - `mouseup`：鼠标弹起\n  - `mousemove`：鼠标移动\n  - `mouseover`：鼠标经过\n  - `mouseout`：鼠标离开\n- 页面\n  - `load`：页面加载完毕\n    - 页面中所有元素全部加载完毕\n- 选中\n  - `select`：文本被选中\n- 表单\n  - `reset`：表单重置\n  - `submit`：表单提交\n\n##### 注册事件\n\n事件名前添加 on 作为事件句柄\n\n- html 使用 事件句柄 作为标签属性\n- 将事件注册，当事件发生时调用函数执行\n\n第一种方式注册事件\n\n- 将函数注册到按钮，事件发生时调用函数\n  - 被调用的函数被称为 回调函数\n\n第二种方式注册事件\n\n- 先获取按钮对象\n- 对按钮对象的 onclick 属性赋值\n  - 将函数事件赋值上去\n- 当事件发生时回调函数执行\n\n```html\n<!-- 注册函数 run() 到事件 load：页面加载完毕后 -->\n<body onload=\"run()\">\n\n<script type=\"text/javascript\">\n    function say() {\n        alert(\"hello\");\n    }\n    //页面加载完毕后执行此函数\n    function run(){\n        //通过 id 获取按钮对象，将函数事件注册到按钮\n        document.getElementById(\"btn\").onclick = say;\n        //直接赋值函数到事件属性：匿名函数，也是回调函数\n        document.getElementById(\"btn\").onclick = function(){ alert(\"二狗\") };\n    }\n    //简化写法，使用 window 对象调用 load 事件，省略 window\n    onload = function() {\n        document.getElementById(\"btn\").onclick = say;\n    }\n</script>\n<!-- 将函数事件直接注册到按钮  -->\n<input type=\"button\" value=\"单击问好\" onclick=\"say()\">\n<!-- 纯 js 注册，根据按钮 id 为按钮的事件属性赋值 -->\n<input type=\"button\" value=\"问好\" id=\"btn\">\n</body>\n```\n\n- html 中页面按语句顺序执行\n  - 先加载 script 脚本，此时按钮 id 还未加载，发生错误\n- body 标签中添加事件 load\n  - 将注册按钮放到 run()\n  - 加载页面完成后执行 run() 函数\n- 直接在 脚本块中使用 window 对象调用 onload 属性\n  - 将要加载 按钮 id 的函数绑定到 load 事件\n  - 在页面加载完成后执行 回调函数\n- 不使用 load 事件，将脚本放到按钮定义语句之后也行\n\n```html\n<body>\n<script type=\"text/javascript\">\n    //页面加载后触发事件\n    onload = function() {\n        //函数注册到 click，单击触发事件\n        document.getElementById(\"btn\").onclick = function (){\n            //将 id 为 text 的标签类型改为 checkbox\n            document.getElementById(\"text\").type=\"checkbox\"\n        }\n    }\n</script>\n<input type=\"text\" value=\"文本框\" id=\"text\" >\n<!-- 点击按钮时将文本框改为复选框 -->\n<input type=\"button\" value=\"改变文本框\" id=\"btn\">\n</body>\n```\n\n##### 事件对象\n\n- 事件触发后浏览器可以捕捉到事件对象\n  - 在回调函数中添加形参可以接收 事件对象\n- 对键盘事件都有 key 属性获取键值\n  - 类型：String；区分大小写\n  - 原属性 keycode：Number；该属性已被弃用\n\n捕捉回车事件：`key === “Enter”`\n\n```html\n<body>\n<script type=\"text/javascript\">\n    onload = function() {\n        document.getElementById(\"text\").onkeydown = function (event){\n            //浏览器调用回调函数自动为形参赋值：值为事件对象\n            //键盘事件 key 属性为 键值，可以检测按下的键是哪个\n            if (event.key === \"Enter\"){\n                alert(\"提交\")\n            }\n        }\n    }\n</script>\n<input type=\"text\" value=\"回车提交\" size=\"10\" id=\"text\">\n</body>\n```\n\n#### 运算符\n\n- 大部分运算符和 Java 中相同\n\n- 运算符 `typeof`\n  - 在程序运行阶段动态获取变量的数据类型\n  - 格式：`typeof 变量名 `，运算结果是六个字符串之一（小写）\n    - “undefined”、“number”、“string”、“boolean”\n    - “object”、“function”\n- 等同比较 `==`：判断值相等\n  - `alert(1 == true)`：结果 true，1 等同于 true\n- 全等运算符 `===`：判断值和数据类型相等\n  - `alert(1 === true)`：结果 false，数据类型不同\n\n##### void\n\n- `void(表达示)`：执行表达式但不返回任何结果\n\n```html\n<!--\n保留连接样式，点击触发事件，但不会跳转链接\nvoid 参数值无所谓，不返回任何结果，但语法要求必须有参数\n-->\n<h1>\n    <a href=\"javascript:void(0)\"  onclick=\"alert(\'不跳转\')\">跳转</a>\n</h1>\n```\n\n#### 控制语句\n\n- 使用和 Java 中相同\n\n  - `if ...`\n  - `switch`\n  - `while`\n  - `do ... while`\n  - `for 循环`\n  - `break`、`continue`\n\n- `for ... in`\n\n  ```js\n  var array = {\n      name : \"张三\",\n      age : 18,\n      hobby : \"篮球\"\n  }\n  // for in 遍历\n  //array 是对象，key 为对象属性\n  //当 array 是数组，key 为数组索引\n  for (let key in array) {\n      document.writeln(array[key])\n  }\n```\n\n- `for of`：ES 6 新增\n\n```js\n  //遍历 set 集合\n  for (let element of set) {\n      document.writeln(element)  //输出 set 集合中的元素\n  }\n```\n\n- `with`\n\n  - 将`with`范围内变量添加 形参中的 字符\n  - `with(“u”){alert(“name”)}`：等价 `alert(u.name)`\n\n- `forEach()`：传入函数遍历元素\n```js\n  var array = [2, 4, 56, false, null]\n  //传入函数遍历数组，函数形参就是数组元素\n  array.forEach(function (arr) {\n      document.writeln(arr)\n  })\n```\n\n##### JS 数组\n\n- `var arr = []`\n  - 数组中元素类型随意，数量随意\n\n遍历数组\n\n```html\n<script type=\"text/javascript\">\n    var array = [ 32, \"sadf\", false]\n    for (var i = 0; i < array.length; i++){\n        alert(array[i])\n    }\n</script>\n```\n\n### DOM\n\n- DOM：Document Object Model；文档对象模型\n  - 对网页中节点进行增删改的过程\n  - HTML 文档被当作一颗 DOM 树看待\n    - `var domObj = document.getElementById(\"id\")`\n- 节点的抽象就是 html 标签的分布，整体来看是一颗树的结构\n\n#### document\n\n- 每一个标签就是一个节点\n\n  - `getElementById()`：根据 id 获取单个节点对象\n  - ` getElementsByName()`：根据 name 属性批量获取节点对象\n  - `getElementsByTagName()`：通过标签名获取全部标签节点对象\n  - `getElementsByClassName`：通过 class 属性值批量获取节点对象\n    - 对应 css 类选择器\n  - `children`：获取当前节点的所有子节点\n    - 使用父节点对象调用\n    - 嵌套进标签的标签\n  - 或者找到 父节点的 第一个、最后一个、上一个、下一个 节点\n  - 通过节点对象可以拿到对应标签的所有属性\n    - 并且可以对属性进行设置\n    - innertText、innerHTML 可以设置元素内容\n\n- 删除节点\n\n  - 先获取父节点，通过父节点删除当前节点\n\n    - 可以通过子节点的下标通过父节点指定获取\n\n```js\n    //获取当前节点对象\n    var self = document.getElementById(\"id\");\n    //获取当前节点的父节点对象\n    var parent = self.parentElement;\n    //通过父节点删除当前节点\n    parent.removeChild(self);\n    //根据子节点的下标删除，子节点数组动态变化\n    parent.removeChild(parent.children[1]);\n```\n\n- 插入节点\n\n  - 获得某个节点时可以通过 innerHTML 添加元素\n\n    - 会覆盖原来的内容\n    - `newH2.innerText = \"新节点\"`\n\n  - 通过追加操作添加节点\n\n    - `p2.appendChild(newH2)`追加新节点到父节点的最后\n    - `insertBefro()`：使用父节点在指定节点之前插入节点\n\n  - 创建节点\n\n    - `createElement(\"h2\")`\n\n```html\n    <p id=\"p1\">JavaScript</p>\n    <div id=\"p2\">\n        <p id=\"se\">JavaSE</p>\n        <p id=\"me\">JavaME</p>\n        <p id=\"ee\">JavaEE</p>\n    </div>\n    <script>\n        //获取节点\n        var p1 = document.getElementById(\"p1\")\n        var p2 = document.getElementById(\"p2\")\n        //将 p1 节点追加到 p2 中\n        p2.appendChild(p1)\n        //创建新节点：h2 标签\n        var newH2 = document.createElement(\"h2\")\n        //设置节点 id、元素内容\n        newH2.id = \"nh2\";\n        newH2.innerText = \"新节点\"\n        //或者使用 serAttribute \n        newH2.setAttribute(\"id\", \"h2\")\n        //将新节点追加到 p2 节点中最后\n        p2.appendChild(newH2)\n    </script>\n```\n\n- 使用 普通按钮 提交对密码加密\n\n  - 对按钮节点绑定事件，return 回调函数结果\n  - 先获取密码框的节点\n  - 获取节点 value 值，即提交的密码\n    - 此时也可以对密码校验，通过后返回 true，否则不通过\n  - 将密码加密再将加密后的密码值赋给value\n    - 使用 加密算法（例如 MD5）\n    - 可以通过隐藏域接收密码进行提交\n\n- `write()`：输出到页面显示\n\n- `writeln()`：输出并添加一个空格\n\n- `cookie`：获取 cookie\n\n  - 劫持 cookie 原理\n\n```html\n    <!-- 页面弹窗或网页中发送请求，点击后执行 js 代码 -->\n    <script src = \"aa.js\">\n        //获取 coolie 对象，有缓存的所有信息\n    	document.cookie\n    </script>\n```\n\n  - 服务器端可以设置 `coolie: httponly`防止 cookie\n\n#### innerHTML、innerText\n\n- 相同：设置元素内容\n- 不同：\n  - innerHTML：将后面的字符串当作 html 代码处理\n  - innerText：只会将后面内容作为字符串处理\n\n```html\n<body>\n<script type=\"text/javascript\">\n    onload = function () {\n        document.getElementById(\'b\').onclick = function () {\n            document.getElementById(\"d\").innerHTML = \"<a href=\'\'>链接</a>\"\n         // document.getElementById(\"d\").innerText = \"<h3>测试 Text</h3>\"\n        }\n    }\n</script>\n<input type=\"button\" value=\"设置 div 内容\" id=\"b\">\n<div id=\"d\"></div>\n</body>\n```\n\n#### 正则表达式\n\n##### 对象\n\n创建正则对象\n\n- 语法格式\n- `/正则表达式主体/修饰符(可选)`\n- 修饰符\n  - `i`：执行对大小写不敏感的匹配\n  - `g`：执行全局匹配\n    - 查找所有匹配而非在找到第一个匹配后停止\n  - `m`：执行多行匹配\n    - 前面是正则表达式则不可跟 m\n\n```js\n//第一种使用：直接创建\nvar regExp = /^[1-9]d*$/i\n//第二种使用：使用内置类创建正则对象\nvar regExp = new RegExp(\"^[1-9]d*$\", \"i\")\n```\n\n![正则修饰符](/resources/Images/image-20220307230411908.png)\n\n##### 方法\n\n- test()：测试字符串是否匹配正则格式\n  - `正则对象.test(字符串)`\n  - 结果为 true：格式匹配成功，否则失败\n- exec()：在一个指定字符串中执行一个搜索匹配\n  - 返回一个结果数组或 `null`\n- trim()：字符串方法，去除字符串的前后空格\n\n##### 表单验证\n\n1. 不能为空\n2. 长度合法\n3. 字符组成元素合法\n4. 输入格式合法\n5. 统一失去焦点验证\n   - 失去焦点之后就进行正则验证\n6. 错误提示信息统一在 span 显示\n   - 输入框同一行\n7. 输入框获得焦点时清空错误提示信息\n   - 可选择数据不合法清空输入框数据\n8. 表单所有项输入合法可以提交\n\n#### Date\n\n- JS 内置时间类\n\n```js\n//获取系统当前时间\nvar nowDate = new Date()\n//转换为本地时间格式\ndocument.write(nowDate.toLocaleString() + \"<br/>\");   // 2022/3/8 10:14:56\n//获取 整年格式，getYear() 获取年份后两位\ndocument.write(nowDate.getFullYear() + \"<br>\")\n//获取 月份， 0 ~ 11\ndocument.write(nowDate.getMonth() + \"<br>\")\n//获取 日（年）\ndocument.write(nowDate.getDate() + \"<br>\")\n//获取 日（周）\ndocument.write(nowDate.getDay() + \"<br>\")\n//获取 时\nnowDate.getHours()\n//获取 分\nnowdate.getMinutes()\n//获取秒\nnowDate.getSeconds()\n//获取时间戳，标准时间距今的 毫秒数\ndocument.write(nowDate.getTime() + \"<br>\")\n//时间戳转为时间格式\ndocument.writeln(new Date(3254346522754))\n	//结果：Wed Feb 15 2073 09:08:42 GMT+0800 (中国标准时间)\n```\n\n#### Array\n\n- 数组：`var arr = []`\n\n  - 数组元素类型、数量随意\n  - 赋值的下标随意，自动扩容\n    - 未赋值的位置统一 `undefined`\n\n  或 `var arr = new Array()`\n\n  - 不传参默认长度为 0\n  - 传一个参数定义数组长度\n  - 传多个参数直接将元素添加到数组\n\n- 数组长度可赋值\n\n  - 赋值后若大于原长度会对数组扩容\n  - 否则将丢失后面数据\n\n- JS 中数组可以自动模拟栈结构：先进后出\n\n  - push()：追加到数组尾部\n  - pop()：弹出尾部元素\n  - `unshift()`：压入头部元素\n  - `shift()`：弹出头部元素\n\n- 函数\n\n  - `slice()`：截取 Array 部分返回新数组\n  - `sort()`：排序\n  - `reverse`：元素反转\n  - `concati()`：拼接数组，返回新数组，未修改原数组\n  - `join()`：连接符，打印拼接数组使用特定字符串连接\n\n### BOM\n\nBOM：Browser Object Model；浏览器模型对象\n\n#### window\n\n- 顶级对象：代表浏览器窗口\n- `open()`：开启窗口\n- `close()`：关闭窗口\n- `alert()`：弹出消息框\n- `confirm()`：弹出确认框\n  - 返回值：确认返回 true，取消返回 false\n- `setInterval(funcation, times)`\n  - 每隔时间间隔 times 调用一次函数 funcation，不会主动停止\n  - 返回值可以传给 `clearInterval()` 函数停止调用\n- `clearInterval(v)`\n  - 接收 `setInterval()`函数返回值以停止 `setInterval`函数\n- `eval()`：将字符串当作 JS 代码处理\n- `document`：当前页面对象\n- `history`：历史对象\n  - 代表浏览器的历史记录\n- `location`：地址栏对象\n  - 当前页面的 URL 信息\n- `console`：控制台对象\n  - `console.log()`：打印到控制台输出\n- `Navigator`：浏览器对象\n  - 封装了浏览器的信息\n  - 不推荐不使用，可被人为修改\n- `screen`：屏幕对象，获取屏幕尺寸\n\n将当前窗口设为顶级窗口\n\n```js\n//判断当前窗口是否是顶级窗口\nif(window.top !== window.self){\n    //将顶级窗口的地址设置为当前窗口\n    window.top.location = window.self.location;\n}\n```\n\n#### history\n\n- 浏览器的历史记录\n  - window 的属性：历史对象\n  - `back()`函数：后退操作，回退到上一步\n  - `go()`函数：前进\n  - `forward()`：前进到访问地址\n\n#### location\n\n- 当前页面的 URL 信息\n  - `host`：主机\n  - `href`：url 地址，当前指向位置\n  - `protocol`：协议\n  - `reload()`：重新加载，刷新\n  - `assign()`：设置新的地址，跳转页面\n\n```js\nfunction go() {\n    location = \"https://www.jd.com\"  //默认使用 window 调用\n    window.location = \"https://www.jd.com\"\n    document.location = \"https://www.jd.com\"\n}\n```\n\n#### 向服务器发数据\n\n- `form` 表单提交\n- 超链接：`<a href=\"url\">`\n- `document.location = \"url\"`\n- `window.location = “url”`\n- `window.open(“url”)`\n- 直接地址栏输入 url 提交\n- 以上都可以携带数据给服务器，但只有通过表单提交数据才是动态的\n\n### JSON\n\n- json：JavaScript Object Notation\n  - 数据交换格式，JavaScript 对象标记\n- 轻量级数据交换格式\n  - 体积小、易解析\n- 实际开发有两种常用数据交换格式\n  - json\n    - 轻量级，易解析\n  - xml\n    - 体积较大，解析麻烦\n    - 但语法严谨，银行等机构常用\n\n#### JSON 对象\n\n- 无类型对象\n\n- 语法格式\n\n  - `var json = {\"属性名\":属性值, \"属性名\":属性值}`\n    - `K:V`结构，使用 `,`分隔不同的键值对\n      - k：String 类型\n      - v：必须是以下数据类型之一：\n        - 字符串、数字、JSON 对象\n        - 数组、布尔、null\n        - 字符串值必须由双引号编写\n  - 数据在名称/值对中\n  - 数据由逗号分隔\n  - 花括号容纳对象\n  - 方括号容纳数组\n\n- Java 连接数据库查询数据后将数据在 Java 中转为 json 格式 字符串\n\n  - 将字符串发回浏览器\n  - 浏览器将字符串解析为 json 对象\n\n- 解析 json\n\n  - 函数 `JSON.parse()` 把文本转换为 `js`对象\n  - `eval(\"var jsonObj = \" + fromJava)`\n    - `fromJava`：传到浏览器的 json 格式字符串\n    - `eval()`：函数将字符串作为 js 代码处理\n    - 即 等价于 `var jsonObj = fromJava`创建 json 对象\n  - 通过 JSON.stringify() 把 JavaScript 对象转换为字符串\n\n  ```js\n  //创建 js 对象\n  var json = {\n      name:\"张三\",\n      age:19,\n      sex:\'男\'\n  }\n  //将 js 对象转为 json 字符串\n  var jsonString = JSON.stringify(json)\n  document.write(jsonString)\n  //解析字符串为 json 对象\n  var  object = JSON.parse(jsonString)\n  document.writeln(object)\n```\n\n- json 数组：数组中存放 json 对象\n\n  - `[]`：js 数组\n  - `{}`：json 对象\n\n```js\n//创建 json 数组\nvar jsonArray = [\n    {\"name\":\"张1\", \"age\":\"17\", \"hobby\":\"唱\"},\n    {\"name\":\"张2\", \"age\":\"18\", \"hobby\":\"跳\"},\n    {\"name\":\"张3\", \"age\":\"19\", \"hobby\":\"rap\"}\n]\n//遍历 json 数组\nfor (let i = 0; i < jsonArray.length; i++) {\n    document.writeln(jsonArray[i].name+ \" \" \n                     + jsonArray[i].age + \" \" \n                     + jsonArray[i].hobby + \"<br/>\")\n}\n```\n\n- 嵌套使用：json 对象中嵌套数组，数组中数据为 json 对象\n\n```json\nvar jsonArray = {\n    \"total\":3,\n    \"students\":[\n        {\"name\":\"张三\", \"age\":18, \"hobby\":\"唱\"}, \n        {\"name\":\"张三\", \"age\":18, \"hobby\":\"跳\"},\n        {\"name\":\"张三\", \"age\":18, \'hobby\':\"rap\"} \n    ]\n}\n```\n\n## JQuery\n\n- 类似工具类\n\n- 封装了大量 JavaScript 函数\n\n  - 可以下载文件导入项目使用\n\n```html\n  <!-- 导入 JQuery 文件 -->\n  <script src=\"JQuery/jquery-3.6.0-dev.js\"></script>\n```\n\n  - 或直接使用 cnd 在线引用\n\n```html\n  <!-- CDN 引用 -->\n  <script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>\n```\n\n- 使用公式：`$(selector).action()`\n\n  - `selector`：选择器，就是 CSS 选择器\n  - `action`：事件，传入一个函数对事件做操作\n\n  绑定事件动态显示鼠标移动坐标\n\n```html\n  <p id=\"p1\"></p>\n  <div id=\"div\">\n      范围移动鼠标\n  </div>\n  <script>\n   //将单击事件绑定到 id 为  #btn 的 按钮\n   $(\'#btn\').click(function (){\n       alert(\"提交数据\")\n   })\n  //页面加载后触发事件\n  $(function (){\n      //将鼠标移动事件绑定到 id 为 div 的区域\n      $(\'#div\').mousemove(function (now){\n          //当事件触发时在 id 为 #p1 的节点显示文本数据\n          $(\'#p1\').text(`坐标:${now.pageX}, ${now.pageY}`)\n      })\n  })\n  </script>\n```\n\n### 操作 DOM\n\n```html\n<ul id=\"ul_test\">\n    <li name=\"l1\">1</li>\n    <li class=\"l2\">2</li>\n    <li id=\"l3\">3</li>\n    <li value=\"l4\">4</li>\n    <li>5</li>\n</ul>\n<script>\n    // ul_test：列表父节点，li[name=python]：列表中的字节点\n    //获取文本数据\n    $(\'#ul_test li[name=l1]\').text()\n    //修改文本数据\n    $(\'#ul_test li[class=l2]\').text(\'设置值\')\n    //获取值\n    $(\'#ul_test li[id=l3]\').html()\n    //设置值，以 html 代码格式处理\n    $(\'#ul_test li[value=l4]\').html(\"设置值\")\n    //元素隐藏和显示：设置 display: none\n    $(\'#ul_test li[name=l1]\').hide()  //元素隐藏\n    $(\'#ul_test li[name=l1]\').show()  //元素显示\n</script>\n```\n\n### 选择器\n\n- 原生选择器\n\n  ```js\n  // id 选择器\n  document.getElementById()\n  // name 选择器\n  document.getElementsByName()\n  // 标签选择器\n  document.getElementsByTagName()\n  // 类选择器\n  document.getElementsByClassName()\n  ```\n\n- JQuery 使用这些\n\n  - 还有庞大的选择器种类\n\n	```javaScript\n  $(\'p\').click(function (){})  // 标签选择器\n  $(\'#id\').click(function (){})  // id 选择器\n  $(\'.class\').click(function (){}) // 类选择器\n```\n\n#### 元素选择器\n\njQuery 使用 CSS 选择器来选取 HTML 元素\n\n```js\n$(\"p\") 		  //选取 <p> 元素\n$(\"p.intro\")  //选取所有 class=\"intro\" 的 <p> 元素\n$(\"p#demo\")   //选取所有 id=\"demo\" 的 <p> 元素\n```\n\n#### 属性选择器\n\njQuery 使用 XPath 表达式来选择带有给定属性的元素。\n\n```js\n$(\"[href]\") 			//选取所有带有 href 属性的元素\n$(\"[href=\'#\']\") 		//选取所有带有 href 值等于 \"#\" 的元素\n$(\"[href!=\'#\']\") 		//选取所有带有 href 值不等于 \"#\" 的元素\n$(\"[href$=\'.jpg\']\") 	//选取所有 href 值以 \".jpg\" 结尾的元素\n```\n\n####  CSS 选择器\n\njQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性\n\n```js\n$(\"p\").css(\"background-color\",\"red\");  //所有 p 元素的背景颜色更改为红色\n```\n\n#### 部分实例\n\n| 语法                   | 描述                                                       |\n| :--------------------- | :--------------------------------------------------------- |\n| `$(this)`              | 当前 `HTML` 元素                                           |\n| `$(\"p\")`               | 所有 `<p>` 元素                                            |\n| `$(\"p.intro\")`         | 所有 `class=\"intro\"` 的 `<p>` 元素                         |\n| `$(\".intro\")`          | 所有` class=\"intro\" `的元素                                |\n| `$(\"#intro\")`          | `id=\"intro\"` 的元素                                        |\n| `$(\"ul li:first\")`     | 每个 `<ul>` 的第一个` <li>` 元素                           |\n| `$(\"[href$=\'.jpg\']\")`  | 所有带有以 `\".jpg\"` 结尾的属性值的 href 属性               |\n| `$(\"div#intro .head\")` | `id=\"intro\"` 的 `<div>` 元素中的所有 `class=\"head\"` 的元素 |\n\n## Ajax\n\n- Ajax：Asynchronous JavaScript and XML\n  - 异步的 JavaScript 和 Xml\n  - 无需重新加载整个页面下更新部分网页\n- 不是新的编程语言，是用于创建更好更快交互性更强的 Web 应用技术\n  - 增强 B/S 体验性\n  - 传统网页更新内容需要重新加载整个页面\n\n- 通过 JQuery 使用 Ajax 导入 JQuery\n- 通过 Vue 实现导入 Vue\n\n1. 编写 controlller 方法\n   - 返回 json 数据\n2. 编写 ajax 请求：`$.ajax()`\n   - 部分参数\n     - url：请求地址，待转入的URL地址\n     - type：请求方式\n       - Ajax 默认使用 get 请求\n       - `$.post()`  使用 post 方式发送请求\n     - headers：请求头\n     - data：待发送的数据\n     - content-type：内容编码类型\n     - async：是否异步\n     - timeout：请求超时时间（毫秒）\n     - beforeSend：发送请求前执行的函数（全局）\n     - complete：完成后执行的回调函数（全局）\n     - success：请求成功时的回调函数（全局）\n       - data：请求返回的数据\n       - status：状态\n     - error：失败后执行的回调函数（全局）\n     - accepts：通过请求头发送给服务器\n       - 告诉服务器当前客户端接受的数据类型\n     - datatype：将服务器返回的数据转为指定格式\n       - `\"xml\"`：转为 xml 格式\n       - `\"text\"`：转为普通文本格式\n       - `\"html\"`：作为 html 代码处理，或转为普通文本格式\n       - `\"script\"`：尝试作为 js 脚本执行，将返回值转为普通文本\n       - `\"json\"`：返回内容转为 js 对象\n3. Ajax 绑定事件\n   - 根据不同操作触发事件\n   - 执行回调函数\n\n```html\n<script>\n    // 页面加载完成后触发\n    $(function () {\n        //绑定输入框到失去焦点事件\n        $(\'#username\').blur(function () {\n            // Ajax 发起请求，默认 get 类型\n            $.ajax({ // $.post()  使用 post 方式发送请求\n                //设置请求的 url\n                url: \"demo\",\n                //设置发动的数据：key：username，value：文本框的值\n                data: {\"username\":$(\'#username\').val()},\n                //请求成功后的回调函数\n                success: function (data) {\n                    //将返回的数据显示到文本框后面\n                    $(\'#usernameInfo\').text(data)\n                }\n            })\n        })\n    })\n    //简化写法\n    $(function () {\n        $(\'#username\').blur(function () {\n            //将发起请求的参数直接放到形参列表：url、data、success h\n           $.post(\"demo\",{\"username\":$(\'#username\').val()},function (data){\n                $(\'#usernameInfo\').text(data)\n            })\n        })\n    })\n</script>\n<!-- 文本输入框 -->\n<input type=\"text\" id=\"username\" placeholder=\"请输入用户名\"><span id=\"usernameInfo\"></span>g1\n```', 'JavaScript', 'JS 基础 学习', '1', 38, '0', '0', '2022-04-20 21:28:31', '2022-07-17 17:55:16', 2);
INSERT INTO `blog` VALUES (10, '面向对象基础', '## 面向对象编程\n---\n[TOCM]\n\n---\n\n**OOP：Object-Oriented Programming**\n\n#### 本质\n\n**以类的方式组织代码，以对象的组织（封装数据）**\n\n#### 抽象\n\n类似的对象部分抽取出来\n\n### 三大特性\n\n- 封装\n- 继承\n- 多态\n\n### 角度\n\n#### 认识论\n\n对象：具体的事物\n\n类：抽象的，对对象的抽象\n\n#### 代码运行\n\n先有类后有对象，类是对象的模板\n\n### 继承\n\nsuper 和 this\n\n创建对象时先调用父类的构造方法再调用自身构造方法\n\n##### super\n\n1. super调用父类构造方法必须在构造方法的第一个\n2. super必须只能出现在子类的方法或构造方法中\n3. super 和 this 不能同时使用调用构造方法\n\n##### super 和 this\n\n- 代表对象\n  - this：本身调用的这个对象\n  - super：父类对象的应用\n- 使用条件\n  - this：无需继承也可使用\n  - super：在继承条件下才可以使用\n- 构造方法\n  - this()：本类的构造\n  - super()：父类的构造\n\n### 重载\n\n1. 同一方法名的方法\n2. 必须改变参数列表\n3. 返回值类型可以改变\n4. 方法体可以不变\n5. 访问权限可以更改，异常范围可以更改\n\n### 重写\n\n1. 需要有继承关系，才可以有子类重写父类的方法\n2. 方法名、参数列表完全相同；返回值类型需要完全一样或父类返回值的的派生类\n3. 访问权限可以放开但不能降低、\n4. 抛出的异常范围可以缩小但不可扩大\n\n### 多态\n\n```java\nclass Person{\n    public void run(){\n        System.out.println(\"run\")\n    }\n     public void play(){\n        System.out.println(\"玩\");\n    }\n}\nclass Son extends Person{\n    public void run(){\n        System.out.println(\"跑\")\n    }//重写父类的方法\n    public void eat(){\n        System.out.println(\"吃\")\n    }\n}\n public class Test{\n     public static void main(String[] args){\n         Son son = new Son();\n         Person person = new Son()//向下造型\n         son.run();\n         person.run();//调用子类被重写方法\n         person.eat();\n         //编译错误，因为Person类中没有eat方法\n         son.play();//子类对象调用父类方法\n         person.play();//未被重写，调用自身方法\n     }\n }\n运行结果：\n跑\n跑\n玩\n玩\n/*\n调用方法\n运行时先检测左边声明的对象类型，检测该类中是否有该方法；\n若存在则检测右边实际的对象类型；\n若实际为子类对象，且子类中重写了该方法作则调用子类方法；\n	若未被重写则直接调用父类方法；\n若不存在则编译错误\n*/\n```\n\n1. 方法的多态，属性没有多态\n2. 借由父类和子类间的关系转换类型（向上、向下造型）\n3. 子类重写父类的方法\n4. 父类引用指向子类对象\n5. static 方法为类方法，随类加载，无法重写\n6. final 、private 修饰的方法无法重写\n\n### static\n\n```java\nimport static java.lang.Math.Random;\n//静态导入包\n\npublic class Test{{//可用来赋初始值\n		System.out.println(\"匿名代码块\");\n	}//在static之后，构造方法之前执行\n	static{\n		System.out.println(\"静态代码块，只执行一次\");\n	}//最先执行，随类加载\n	public Test(){\n		System.out.println(\"构造方法\");\n	}//在方法之前需先执行\n    public static void main(String [] args){\n        Test test = new Test();\n    }\n}\n运行结果：\n静态代码块，只执行一次\n匿名代码块\n构造方法\n*************\n匿名代码块\n构造方法\n```\n\n#### 单例模式\n\n饿汉式\n\n1. 构造器私有化\n2. 在类内部创建对象并私有化（为static）\n3. 提供一个公共的方法返回该对象（static）\n4. 通过调用该公共方法来创建一个对象，且无论创建多少次都为同一个对象\n\n```java\nclass A {\n    private AA(){}//构造器私有化\n    private static final AA A = new AA();\n    //在类中创建对象并静态私有化\n    public static AA getInstance(){\n        return A;\n    }//提供公共的方法返回对象\n}\n//饿汉式：在加载类的时候已经创建好了对象，但是可能暂时用不到；可能造成资源的浪费\n```\n\n懒汉式\n\n1. 构造器私有化\n2. 提供一个公共的方法返回该对象（static）\n3. 通过调用该公共方法来创建一个对象，且无论创建多少次都为同一个对象\n4. 只有调用getInstance方法时才会创建对象，后面再次调用时返回上次 创建的对象\n5. 有线程安全问题\n\n```java\nclass B{\n    private static B b;//默认为null\n    private B(){}\n    public static B getInstance(){\n        if (b == null)\n            b = new B();\n        return b;\n    }\n}\n```\n\n\n\n### 抽象类、接口\n\n#### 抽象类\n\nabstract定义抽象类，其中定义的抽象方法，无方法体：为一种约束\n\n1. 继承该类的子类必须实现其中的所有抽象方法，除非子类也是抽象类\n2. 抽象类无法实例化对象\n3. 抽象类不能实例化对象，但是其他功能依旧存在：成员变量、成员方法和构造方法的访问方式和普通类一样\n4. 抽象类中可以有普通方法，但抽象方法必须在抽象类中\n5. 父类包含了子类集合的常见的方法\n\n#### 接口\n\ninterface；本质是契约，制定规则\n\n接口需要实现类（命名一般为后加Impl）\n\n1. 定义一些通用方法作为约束\n\n2. 方法默认为pulbic abstract\n\n3. 属性默认为public static final\n\n4. 一个类可以实现多个接口，但必须重写其中的方法\n\n5. 接口中的方法一般是不能在接口中实现的，只能由实现接口的类来实现接口中的方法，且方法都是共有的\n\n\n- Java 8 新增了接口的默认方法和静态方法：\n\n  默认方法就是接口可以实现方法，不需要实现类去实现其方法；只需在方法名前面加 default 关键字即可实现默认方法（目的是为了解决接口的修改与现有的实现不兼容的问题）\n\n  - 多个默认方法\n    - 创建自己的默认方法，来覆盖重写接口的默认方法\n    - 使用 super 来调用指定接口的默认方法\n\n- Java 9 新增支持私有方法、私有静态方法\n\n  - 接口中private方法不能是abstract抽象方法：abstract抽象方法是公开的用于给接口实现类实现的方法，所以不能是private\n  - 接口中私有方法只能在接口内部的方法里面被调用\n  - 接口中私有静态方法可以在其他静态和非静态接口方法中使用\n  - 接口中私有非静态方法不能在私有静态方法内部使用\n\n### 内部类\n\n#### 成员内部类\n\n在一个类的内部写一个类\n\n可以获取外部类所有属性和方法（包括私有的的）\n\n```java\n class Outer{\n	private int age;\n    public void out(){\n        System.out.println(\"外部类\");\n    }\n    public class Inner{\n        public void in(){\n            System.out.println(\"内部类\");\n        }\n    }\n}\npublic class Test{\n    Outer outer = new Outer();\n    Outer.Inner inner = outer.new Inner; //Outer.Inner inner = new Outer().new Inner();\n    inner.in();\n}\n```\n\n#### 静态内部类\n\n无法获取外部类变量和方法\n\n#### 局部内部类\n\n方法内部定义，可以获取外部类的所有属性和方法，但只能获取外部方法definal变量\n\n#### 匿名类\n\n没有名字的类\n\n在new对象的时候给出类的定义形成匿名类，可以继承某类，也可以实现接口，swing的消息机制广泛使用匿名类\n\n```java\nJButton btnStep = new JButton(\"单步\");//定义一个按钮\nframe.add(benStep,BorderLayout.NORTH);//添加按钮在绘好的图形中，并定义位置在north（上面）\nbtnStep.addActionListener(new AcctionListener){//内部类（匿名类）\n    @Override\n    public void actionPerformed(ActionEvent e){\n        System.out.println(\"\");\n        step();//外部类定义的方法\n    }\n}\n//调用JBUtton类的接口并new一个东西（定义一个类来实现接口，将对象注册在按钮上，从而使JButton定义的按钮和要实现的对象产生关系，使得按钮按下时会反过来调用对象的函数（注入反转））\n\n```\n\n### 异常\n\n```java\ntry{\n	//要执行的操作\n}catch(异常类型 变量名){\n	//捕获异常后的操作\n}finally{\n	//无论是否捕获异常都执行\n}\n```\n\n', 'Java', 'Java 面向对象 基础', '1', 43, '0', '0', '2022-04-27 22:17:03', '2022-07-17 17:55:04', 2);
INSERT INTO `blog` VALUES (11, '正则表达式', '# 正则表达式\n---\n[TOCM]\n\n---\n一、校验数字的表达式\n1 数字：^[0-9]*$\n2 n位的数字：^\\d{n}$\n3 至少n位的数字：^\\d{n,}$\n4 m-n位的数字：^\\d{m,n}$\n5 零和非零开头的数字：^(0|[1-9][0-9]*)$\n6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n7 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$\n8 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$\n9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n11 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\n12 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$\n13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n15 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$\n16 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$\n17 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\n18 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n19 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\n\n二、校验字符的表达式\n1 汉字：^[\\u4e00-\\u9fa5]{0,}$\n2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n3 长度为3-20的所有字符：^.{3,20}$\n4 由26个英文字母组成的字符串：^[A-Za-z]+$\n5 由26个大写英文字母组成的字符串：^[A-Z]+$\n6 由26个小写英文字母组成的字符串：^[a-z]+$\n7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n11 可以输入含有^%&\',;=?$\\\"等字符：[^%&\',;=?$\\x22]+\n12 禁止输入含有~的字符：[^~\\x22]+\n\n三、特殊需求表达式\n1 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\n3 InternetURL：[a-zA-z]+://[^\\s]* 或 ^https://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\n4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n5 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ \n6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n7 身份证号：\n	15或18位身份证：^\\d{15}|\\d{18}$\n	15位身份证：^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$\n	18位身份证：^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{4}$\n8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ \n12 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ \n15 钱的输入格式：\n16 1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ \n17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ \n18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ \n19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ \n20 5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$ \n21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ \n22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ \n23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ \n24 备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$\n26 中文字符的正则表达式：[\\u4e00-\\u9fa5]\n27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)\n29 HTML标记的正则表达式：<(\\S*?)[^>]*>.*?|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n30 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)\n32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)\n33 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)', '正则', '正则 基础 学习', '1', 33, '1', '0', '2022-05-15 21:31:09', '2022-07-17 17:54:54', 1);
INSERT INTO `blog` VALUES (12, 'HTML', '# HTML\n---\n\n[TOCM]\n\n---\n### 网页\n\n- 块元素\n  - 无论内容多少都独占一行\n  - `<p>`、`<h1 ~ 6>` 等\n- 行内元素\n  - 内容撑开宽度\n    - 左右都是行内元素的可排在第一个\n  - 不会换行\n- 标签可以嵌套使用\n\n#### 基本信息\n\n- `<!-- -->`：注释\n- `<!DOCTYPE>` ：声明，不是 html 标签\n	- 指示 web 浏览器页面使用的 HTML 版本\n  	- 必须是 HTML 文档的第一行，位于 `<html>` 标签之前\n  	- 没有结束标签，大小写不敏感\n- `<html lang=\"en\">`\n  	- 告知浏览器其是一个 HTML 文档\n  	- 标签限定了文档的开始点和结束点，之间是文档的头部和主体\n  	- lang：language——code，规定元素中内容的语言代码\n  	- en：English，网页定义为英文网页\n  	- xmlns：在文档中定义一个或多个可供选择的命名空间\n    	- 可以放置在文档内任何元素的开始标签中，值类似于 `URL`\n		- 最好在文档的开头处定义具有前缀的命名空间\n      	- 整个文档范围可用\n    - 定义命名空间后浏览器会将此命名空间用于该属性所在元素内的所有内容\n- `<head>`：头部标签\n  	- 用于定义文档的头部，是所有头部元素的容器\n  	- 其中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等\n- `<meta>`：提供有关页面的元信息，永远位于 head 元素内部\n  	- 比如针对搜索引擎和更新频度的描述和关键词\n  	- 标签的属性定义了与文档相关联的名称/值对\n    - 元数据总是以名称/值的形式被成对传递的\n- `<title>`：定义文档的标题\n  	- `<head>` 标签中唯一要求包含的东西\n- `<body>`：定义文档的主体\n  	- 包含文档的所有内容\n    - 比如文本、超链接、图像、表格和列表 等\n\n```html\n<!-- 初始的 html 页面 -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>网页标题</title>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n| 标签         | 描述               |\n| :----------- | :----------------- |\n| `<!DOCTYPE>` | 定义文档类型       |\n| `<html>`     | 定义 HTML 文档     |\n| `<head>`     | 定义关于文档的信息 |\n| `<title>`    | 定义文档的标题     |\n| `<body>`     | 定义文档的主体     |\n| `<h1>~<h6>`  | 定义 HTML 标题     |\n| `<p>`        | 定义段落           |\n| `<br/>`      | 定义简单换行       |\n| `<hr/>`      | 定义水平线         |\n| `<!-- -->`   | 定义注释           |\n\n#### 基本标签\n\n- 标签都是成对出现，尾标签相对于首标签添加 `/`\n- 自闭和标签可以直接在首标签尾部追加 `/`\n\n```html\n<h1></h1>一级标题\n<!-- h2 ~ h6 六级标签，逐级变小 -->\n<h6></h6>六级标题\n<p>段落，独占一行</p>\n<br/>换行\n<hr/>水平线标签\n<strong>粗体标签</strong>\n<em>斜体标签</em>\n<!-- 注释 -->\n```\n\n| 符号 | 描述   | 转自字符            | 字符编号 |\n| :--- | :----- | :------------------ | :------- |\n|      | 空格   | `&nbsp;`            | `&#160;` |\n| <    | 小于号 | `&lt;`              | `&#60;`  |\n| >    | 大于号 | `&gt;`              | `&#62;`  |\n| &    | 和号   | `&amp;`             | `&#38;`  |\n| \"    | 引号   | `&quot;`            | `&#34;`  |\n| \'    | 撇号   | `&apos; `(IE不支持) | `&#39;`  |\n\n#### 图像标签\n\n- `../`表示上级目录\n  - 一般不使用绝对路径，使用项目中的相对路径\n- 必填 `src、alt` 属性，其他可不设置\n  - src：图片路径\n  - alt：图片无法显示时的替代文字\n\n```html\n<img src=\"图像地址\" alt=\"图像代替文字\" title=\"鼠标悬停提示文字\" width=\"图像宽度\" heifht=\"图像高度\">\n<!-- 示例 -->\n<img src=\"../image/全家福.jpg\" alt=\"全家福\" title=\"全家福\" width=\"500\" height=\"200\"/>\n```\n\n#### 链接标签\n\n- `<a>`：定义超链接，从一张页面链接到另一张页面\n  - 最重要的属性是 href 属性，指示链接的目标\n  - href：连接路径，必填\n  - target：连接打开的窗口\n    - 常用值\n    - `_self`：当前页面打开\n    - `_blank`：新标签页打开\n    - framename：在指定框架中打开\n  - 标签中可以嵌套图片实现图片超链接\n\n| 值        | 描述                                 |\n| :-------- | :----------------------------------- |\n| _blank    | 在新窗口中打开被链接文档。           |\n| _self     | 默认。在相同的框架中打开被链接文档。 |\n| _parent   | 在父框架集中打开被链接文档。         |\n| _top      | 在整个窗口中打开被链接文档。         |\n| framename | 在指定的框架中打开被链接文档。       |\n\n- 锚链接\n  - 需要一个锚标记：`<a name=\"锚点名\"></a>`\n  - 可以跳转到标记：`<a href=\"#锚点名\"></a>`\n    - 另一个页面有锚点时\n    - 可以跳到指定连接的指定位置\n- 功能性链接\n  - 邮件链接\n    - `<a href=\"mailto:邮箱地址\"></a>`\n  - QQ链接\n    - 通过 QQ 推广生成链接粘贴到页面\n\n```html\n<a href=\"path\" target=\"要打开的目标窗口位置\">链接文本或图像</a>\n<!-- 示例：使用图片作为超链接，在当前页面打开 -->\n<a href=\"https://www.baidu.com\" target=\"_self\">\n    <img src=\"../image/全家福.jpg\" alt=\"全家福\">\n</a>\n<!-- 示例：锚链接 -->\n<a name=\"top\">顶部</a>\n<a href=\"#top\">回到顶部</a>\n<!-- 功能链接：邮箱 -->\n<a href=\"mailto:邮箱\"></a>\n```\n\n#### 列表标签\n\nl：list，列表\n\n- 有序列表：`<ol>`（orderlist）\n  - `<li>`：列表元素\n  - 显示行编号\n- 无序列表：`<ul>`（unlist）\n  - `<li>`：列表元素\n  - 显示原点，无编号\n- 自定义列表：`<dl>`（diylist）\n  - `<dt>`自定义列表标题\n  - `<dd>`：列表内元素\n- 列表内可进行嵌套\n\n```html\n<ol>\n    <!-- 每一列都是单独一行 -->\n    <li>有序1</li>\n    <li>有序2</li>\n</ol>\n<ul>\n    <li>无序1</li>\n    <li>无序2</li>\n</ul>\n<dl>\n    <dt>分类</dt>\n    <dd>java</dd>\n    <dd>web</dd>\n</dl>\n```\n\n#### 表格\n\n- `<table>`：表格\n  - board：表格边框宽度\n- `<tr>`：行\n  - rowspan：跨行（合并行）\n- `<td>`：列\n  - colspan：跨列（合并列）\n\n```html\n<table border=\"1\" >\n    <tr>\n        <td rowspan=\"2\">1-1</td>\n        <td colspan=\"2\">1-2</td>\n    </tr>\n    <tr>\n        <td colspan=\"\">2-1</td>\n        <td rowspan=\"2\">2-2</td>\n    </tr>\n    <tr>\n        <td colspan=\"2\">3-1</td>\n    </tr>\n</table>\n```\n\n#### 媒体元素\n\n- 音频\n  - `<audio>`\n- 视频\n  - `<video>`\n- 部分组件\n  - src：文件路径\n  - controls：显示控件\n  - autoplay：自动播放\n\n```html\n<!-- 视频 -->\n<video src=\"../image/早木璇子.mp4\" controls autoplay></video>\n<!-- 音频 -->\n<audio src=\"../image/早木璇子.mp4\" controls autoplay></audio>\n```\n\n### 页面结构\n\n| 元素名  | 描述                                                         |\n| ------- | ------------------------------------------------------------ |\n| header  | 页眉，标题头部内容，用于页面或页面中一块区域                 |\n| footer  | 页脚（可多次使用），用于页面或页面中一块区域                 |\n| section | 页面中的独立区域<br />比如章节、页眉、页脚或文档中的其他部分 |\n| article | 独立的文章内容                                               |\n| aside   | 与周围内容相关，常用做侧栏                                   |\n| nav     | 定义导航链接部分                                             |\n\n### iframe 内联框架\n\n- `<iframe src=\"引用页面地址\" name=\"框架标识名\"></iframe>`\n  - src：地址\n  - width、height：宽度、高度\n  - name：框架名字\n    - 可使用 `<a target=\"框架名字\">`在指定框架中打开链接\n- 创建包含另外一个文档的内联框架（即行内框架）\n  - 在当前页面内打开\n\n| 属性           | 值                               | 描述                                                         |\n| :------------- | :------------------------------- | :----------------------------------------------------------- |\n| [align]        | left、right、top、middle、bottom | 不赞成使用，使用样式代替。规定如何根据周围的元素来对齐此框架。 |\n| [frameborder]  | 1、0                             | 规定是否显示框架周围的边框。                                 |\n| [height]       | pixels、%                        | 规定 iframe 的高度。                                         |\n| [marginheight] | pixels                           | 定义 iframe 的顶部和底部的边距。                             |\n| [marginwidth]  | pixels                           | 定义 iframe 的左侧和右侧的边距。                             |\n| [name]         | frame_name                       | 规定 iframe 的名称。                                         |\n| [scrolling]    | yes、no、auto                    | 规定是否在 iframe 中显示滚动条。                             |\n| [seamless]     | seamless                         | 规定 `<iframe>` 看上去像是包含文档的一部分。                 |\n| [width]        | pixels、%                        | 定义 iframe 的宽度。                                         |\n\n### 表单\n\n#### input\n\n- `<form>`：表单\n  - method：发送数据的方法\n    - post、get、put、delete\n    - get 提交信息会在 url 中显示，但高效\n    - post 不会显示在 url 中\n  - action：表示向何处发送表单数据\n    - 网站或请求处理地址\n- `<input>`：用于搜集用户信息（输入框）\n  - 不同的 type 属性值，输入字段拥有多种形式\n  - 通过 name 上传，上传的值为 value\n  - text：文本框\n    - name：名称\n    - value：输入的值，可以指定默认值；被提交数据\n  - radio、cheakbox：单选、多选框\n    - value：值，必须有；用来提交\n    - name：相同的name表示属于同一组单选框\n    - check：默认选择\n  - 按钮：\n    - button：普通按钮\n    - image：图片按钮\n    - submit：提交按钮\n    - reset：重置按钮\n    - 按钮的 value 值显示在 按钮界面上\n  - 文件域：file\n    - entype=“multipart/form-data”  \n    - 不对字符编码。使用包含文件上传控件的表单时，必须使用该值\n  - 一些功能类型验证输入的数据是否符合格式\n  - disabled：禁用\n    - 使用此属性的标签会失效无法操作\n    - 标签变为 灰色\n  - readonly：只读\n    - 设置后该标签内只能查看无法修改\n    - 标签设置 value 后有初始值但无法修改\n  - hidden：隐藏域\n    - 使用此属性的标签不会显示在页面\n    - 但是仍存在可以提交\n      - 标签设置 value 默认值且不允许查看\n- 下拉框：使用 `<select>`\n  - `<option>`：下拉框内使用\n  - `selected`：默认选中\n- 文本域：`<textarea>`\n  - name：文本域名字\n  - rows、cols：行、列数\n- `<lable>`：增强鼠标可用性\n  - label 元素内点击文本会自动将焦点转到和标签相关的表单控件上\n  - for 属性与相关元素的 id 属性相同\n    - 指定后可以跳转到该 id 对应的输入框\n    - 默认为 `<lable>` 域内第一个 input 语句\n\n```html\n<form action=\"demo.html\" method=\"get\">\n\n    <label>\n        单选\n        <!-- 默认张三 -->\n        <input type=\"radio\" value=\"张三\" checked name=\"radio\">张三\n        <input type=\"radio\" value=\"李四\" name=\"radio\">李四\n        <br/>\n        复选\n        <!--  默认 张三 -->\n        <input type=\"checkbox\" value=\"张三\" checked name=\"check\">张三\n        <input type=\"checkbox\" value=\"李四\" name=\"check\">李四\n        <input type=\"reset\" name=\"reset\" value=\"重置\">\n    </label>\n    <br/>\n    <label>\n        下拉框\n        <select name=\"select\">\n            <!-- 默认中国 -->\n            <option name=\"瑞士\" value=\"瑞士\">瑞士</option>\n            <option name=\"china\" value=\"中国\" selected>中国</option>\n        </select>\n    </label>\n    <br/>\n    <label>\n        文本域<br/>\n        <textarea name=\"textarea\" rows=\"5\" cols=\"10\" >文本域</textarea>\n    </label>\n\n    <label>\n        文件域名<br/>\n        <input type=\"file\" name=\"file\" value=\"上传文件\">\n        <input type=\"button\" name=\"button\" value=\"上传\">\n    </label>\n\n    <br/>\n\n    <!-- for 属性指定点击文字时跳转 email 框 -->\n    <label for=\"aa\">\n        邮箱格式验证<br/>\n        <input type=\"email\" name=\"email\" id=\"aa\"><br/>\n        URL 验证<br/>\n        <input type=\"url\" name=\"url\"><br/>\n        数字限制<br/>\n        <input type=\"number\" max=\"10\" min=\"0\"><br/>\n        滑块<br/>\n        <input type=\"range\" name=\"range\" min=\"0\" max=\"20\" step=\"2\">\n        搜索框<br/>\n        <input type=\"search\" name=\"search\">\n    </label>\n    <br/>\n    <label>\n        文本输入框&nbsp;<input name=\"姓名\" type=\"text\" value=\"张三\"><br/>\n        提交按钮&nbsp;<input type=\"submit\" value=\"提交\"><br/>\n    </label>\n</form>\n```\n\n| input属性 | 值                                                           | 描述                                    |\n| :-------- | :----------------------------------------------------------- | :-------------------------------------- |\n| type      | button、checkbox、file、hidden、image、password、radio、reset、submit、text | 规定 input 元素的类型，默认 text        |\n| name      | field_name                                                   | 定义 input 元素的名称                   |\n| value     | *value*                                                      | 初始值，radio 时必须指定                |\n| checked   | checked                                                      | 默认选中                                |\n| alt       | text                                                         | 定义图像输入的替代文本                  |\n| size      | number_of_char                                               | 输入框长度                              |\n| src       | URL                                                          | 定义以提交按钮形式显示的图像的 URL      |\n| list      | *datalist-id*                                                | 引用包含输入字段的预定义选项的 datalist |\n| maxlength | number                                                       | 规定输入字段中的字符的最大长度          |\n| max       | *number*、*date*                                             | 规定输入字段的最大值                    |\n| min       | *number*、*date*                                             | 规定输入字段的最小值                    |\n| align     | left、right、top、middle、bottom                             | 不赞成使用。规定图像输入的对齐方式      |\n| readonly  | readonly                                                     | 规定输入字段为只读                      |\n| required  | required                                                     | 指示输入字段的值是必需的                |\n| disabled  |                                                              | 标签禁用                                |\n| readonly  |                                                              | 只读                                    |\n| hidden    |                                                              | 隐藏标签                                |\n\n#### 表单初级验证\n\n#### input 属性\n\n| 属性           | 值                                                           | 描述                                                         |\n| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| type           | button、checkbox、file、hidden、image、password、radio、reset、submit、text | 规定 input 元素的类型                                        |\n| name           | field_name                                                   | 定义 input 元素的名称，提交数据的 key                        |\n| value          | value                                                        | 规定 input 元素的值，提交数据的 value                        |\n| src            | URL                                                          | 定义以提交按钮形式显示的图像的 URL                           |\n| size           | number_of_char                                               | 定义输入字段的宽度                                           |\n| alt            | text                                                         | 图片无法显示时的信息                                         |\n| step           | number                                                       | 规定输入字的的合法数字间隔                                   |\n| readonly       | readonly                                                     | 规定输入字段为只读                                           |\n| placeholder    | text                                                         | 提示信息，输入内容后自动消失                                 |\n| required       | required                                                     | 指示输入字段的值是必需的                                     |\n| checked        | checked                                                      | 选择框内默认选中                                             |\n| disabled       | disabled                                                     | 当 input 元素加载时禁用此元素                                |\n|                |                                                              |                                                              |\n| pattern        | regexp_pattern                                               | 正则验证输入的内容格式                                       |\n| maxlength      | number                                                       | 规定输入字段中的字符的最大长度                               |\n| max            | number、date                                                 | 规定输入字段的最大值；与 \"min\" 属性创建合法值的范围          |\n| min            | number、date                                                 | 规定输入字段的最小值；与 \"max\" 属性创建合法值的范围          |\n| accept         | mime_type                                                    | 规定通过文件上传来提交的文件的类型                           |\n| align          | left、right、top、middle、bottom                             | 不赞成使用；规定图像输入的对齐方式                           |\n| autocomplete   | on、off                                                      | 规定是否使用输入字段的自动完成功能                           |\n| autofocus      | autofocus                                                    | 规定输入字段在页面加载时是否获得焦点；不适用于 type=\"hidden\" |\n| form           | formname                                                     | 规定输入字段所属的一个或多个表单                             |\n| formaction     | URL                                                          | 覆盖表单的 action 属性；适用于 type=\"submit\" 和 type=\"image\" |\n| formenctype    | 见注释                                                       | 覆盖表单的 enctype 属性；适用于 type=\"submit\" 和 type=\"image\" |\n| formmethod     | get、post                                                    | 覆盖表单的 method 属性；适用于 type=\"submit\" 和 type=\"image\" |\n| formnovalidate | formnovalidate                                               | 覆盖表单的 novalidate 属性；如果使用该属性，则提交表单时不进行验证 |\n| formtarget     | `_blank、_self、_parent、_top、framename`                    | 覆盖表单的 target 属性；适用于 type=\"submit\" 和 type=\"image\" |\n| list           | datalist-id                                                  | 引用包含输入字段的预定义选项的 datalist                      |\n| multiple       | multiple                                                     | 该属性允许一个以上的值                                       |\n| height         | pixels、%                                                    | 定义 input 字段的高度；适用于 type=\"image\"                   |\n| width          | pixels、%                                                    | 定义 input 字段的宽度；适用于 type=\"image\"                   |\n\n## CSS\n\n- CSS：Cascading Style Sheet\n  - 层叠样式表语言\n- 用来修饰  HTML 页面\n  - 设置 HTML 页面中某些元素的样式\n  - HTML 是主体，CSS 依赖 HTML 存在\n\n#### 嵌套 CSS\n\n- 内联定义：在 HTML 标签内部使用\n\n  - 已被废弃\n\n- 内联样式块：`<head>`标签内使用 `<style>`制定样式\n\n  ```html\n  <style type=\"text/css\">\n      选择器{\n          样式定义\n      }\n  </style>\n  ```\n\n- 单独定义外部样式文件\n\n  - 在需要时通过链接引入\n  - rel 属性是必须的\n    - 规定当前文档与被链接文档/资源之间的关系\n\n  ```html\n  <link type=\"text/css\" href=\"css文件地址\" rel=\"stylesheet\"/>\n  ```\n\n#### 选择器\n\n- id 选择器：`#id名{ 定义样式 }`\n- 标签选择器：`标签类型{ 定义样式 }`\n  - 范围更广，相同类型标签\n- 类选择器：`.类名{ 定义样式 }`\n  - 可以跨标签使用，在 html 标签中定义 class 属性\n  - 指定同一类的标签样式', 'HTML', 'html  基础 学习', '1', 28, '0', '0', '2022-05-16 17:18:56', '2022-07-17 17:54:42', 3);
INSERT INTO `blog` VALUES (13, 'About Me', '# About Me\n---\n[TOCM]\n\n\n---\n\n### 我是一个普通人，普罗大众的一员\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<U> 学习总是一件很枯燥的事情，尤其是对于一个生性懒惰的人</U>\n<br/>\n```java\nwhile(true) {\n  System.out.pringln( \" 帅哥你好，\" )\n  System.out.println( \" 虽然你已经很帅了，但还是比作者差亿点点 |- _ -|\" )\n  System.out.println( \" 如果你是美女，那么（|^ _ ^|）嘿嘿嘿 \")\n}\n```\n<br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by 一个普通的正在学习的新手程序员', 'About', 'About_Me 开始', '1', 451, '0', '0', '2022-05-25 20:06:36', '2022-07-17 17:53:56', 11);
INSERT INTO `blog` VALUES (14, '反射', '## 类加载\n\n---\n[TOCM]\n\n---\n\n#### Java程序阶段\n\n1. 代码/编译 阶段：源码 → 字节码文件 （通过类加载器进入下一阶段）\n2. Class类加载阶段\n3. 程序运行阶段\n\n- 1 → 2 ：JVM底层反射\n- 2 → 3： 反射应用\n- ![Java程序阶段](/resources/Images/image-20211122153759634.png)\n\n### 类加载\n\n反射机制是Java实现动态语言的关键，及通过反射实现类动态加载\n\n1. 静态加载：编译时加载相关的类，若没有则报错，依赖性太强\n\n2. 动态加载：运行时加载需要的类，若运行时不用该类则不报错，降低依赖性\n\n3. 加载时机\n	- 创建对象时（new）\n   	- 子类被加载时\n   	- 调用类中的静态成员时\n   	- 通过反射\n  	 1. 子类直接调用父类静态变量不会加载子类\n	 2. 调用静态常量不会加载类\n\n```java\nclass Father{\n	static int a = 10;\n      static {System.out.println(\"Father被加载\");}\n}\nclass Son extends Father{\n	static final int b = 10;\n    static {System.out.println(\"Son被加载\");}\n}\npublic class Test{\n	static {\n    	System.out.println(\"Test被加载\");\n	}\n    public static void  main(String[] args){\n    	//加载 测试类 和 父类\n        System.out.println(\"a = \" + Son.a);\n        //加载测试类，父类 和 子类 都不被加载\n		System.out.println(\"b = \" + Son.b);\n	}\n}\n运行结果：\nTest被加载\nFather被加载\na = 10\nb = 10\n```\n\n\n![类加载三个阶段](/resources/Images/image-20211123083255293.png)\n\n- JVM完成\n  	- 加载：将字节码从不同的数据源（class文件、jar包甚至是网络）幻化为**二进制字节流加载到内存**中，并为其创建一个代表该类的java.lang.Class对象；由类加载器完成\n  	- 链接Linking：将类的二进制数据合并到JRE中\n    	 - 验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全\n      		- 包括：文件格式验证（是否以魔数 oxcafebabe开头）、元数据验证、字节码验证和符号引用验证；可考虑使用 -Xverify:one 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间\n    	- 准备：对静态变量分配空间并默认初始化（对应数据类型的默认初始值）；这些变量所使用的内存将在方法区进行分配\n    	- 解析：把常量池的符号引用转换为直接引用的过程\n      		- 原来定义的类名（符号）转换为该类在内存中的Class对象地址（直接地址）\n\n- 程序员可控\n\n	  - 初始化：Initialization；执行类中定义的Java程序代码，执行`<clinit>()`方法的过程（是在类加载的过程中，所以只会初始化静态成员及静态代码块）\n    	- `<clinit>()`方法是编译器**按语句在源文件中出现的顺序**依次自动收集类中所有的静态变量的赋值动作和静态代码块中的语句，并进行合并\n    	- 虚拟机会保证一个类的 `<clinit>()`方法在多线程环境中正确的被加锁、同步：如果多线程同时去初始化一个类，只会有一个线程执行该类的 `<clinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行完毕\n\n#### 类加载器\n\n类加载器：`ClassLoader`\n\n- Java语言提供系统环境变量 CLASSPATH\n  	- 该环境属性是 JVM 进程启动的时候进行类加载路径的定义\n- 在 JVM 中可以根据类加载器进行指定路径中类的加载\n 	 - 即：找到类加载器就是找到了类的来源\n\n#### 系统类加载器\n\n1. `Boootstrap`：根加载器，系统类加载器（系统内部，不可加）\n2. `PlatformClassLoader`：平台加载器\n   	- JDK1.9 及以后提供\n		- 为了在系统类加载器和应用类加载器之间保持设计的平衡\n   	- JDK1.8及以前为扩展类加载器：`ExtClassLoader`\n     	- JDK1.8及以前的安装目录中提供 ext 目录，可将 `*.jar`文件拷贝到该目录直接执行\n     	- 但这种开发处理并不安全，一直不提倡使用，JDK9开始废除\n3. AppClassLoader：应用类加载器\n\n- 想获得类加载器必须通过 ClassLoader\n  	- 获取 ClassLoader 对象必须利用 Class 类（反射的根源）实现\n    	- `public ClassLoader getClassLoader();`\n  	- 获得 ClassLoader 对象后还可以继续获取其父类的 ClassLoader 对象\n    	- `public final ClassLoader getParent(); `\n\n![类加载器获取与分类](/resources/Images/b4d5b1d2225e4a408bc9359f626df2c3.png)\n\n#### 自定义类加载器\n\n自定义类加载器加载顺序在所有类加载器之后\n\n- 双亲加载机制\n  	- 程序类为系统提供类会由系统加载\n 	 - 自定义类与系统类名相同，那为了保证系统安全性绝对不会加载\n\n系统类加载器是根据 CLASSPATH 路径进行类加载\n\n- 而自定义类加载器可以任意指派类的加载位置\n\n1. 随意编写Java类，将其保存在本地磁盘\n 	  - `public class Message{}`\n2. 将其拷贝到D盘编译处理，且不打包\n   	- `javac Message.java`\n 	  - 此时没有进行打包处理，所以该类无法通过CLASSPATH正常加载\n3. 自定义加载类，继承 ClassLoader 类\n 	  - ClassLoader 类有字节转为类结构的方法\n 	  - `protecrted final Class<?> defineClass(String name, byte[] b, int off, int len) throws ClassFormatError`\n4. 若结合网络开发可以通过远程服务器来确定类的功能\n\n##### 示例\n\n```java\n//自定义加载器类\nclass Loader extends ClassLoader{\n    //加载类，传入类名（全称）\n    public  Class<?> load(String className) {\n        ByteArrayOutputStream by = new ByteArrayOutputStream();\n        byte[] data = null;\n        try {\n            //文件读取流，将class文件读取\n            FileInputStream inputStream = new FileInputStream(\"D:\\\\A.class\");\n            //转存到字节数组流\n            inputStream.transferTo(by);\n            //从字节数组流输出到字节数组\n            data = by.toByteArray();\n            inputStream.close();\n            by.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (data != null) {\n            //数组数据不为空时 执行将字节文件转为类结构\n            return super.defineClass(className, data, 0, data.length);\n        }\n        return null;\n    }\n}\n//测试类\npublic class Test{\n    public static void main(String[] args) {\n        //通过自定义加载器加载类 A\n        Class<?> load = new Loader().load(\"demo03.A\");\n        try {\n            //获取类 A 中 send 方法对象\n            Method send = load.getDeclaredMethod(\"send\");\n            //获取类 A 实例对象\n            Object o = load.getDeclaredConstructor().newInstance();\n            //执行 send 方法\n            send.invoke(o);\n        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 反射\n\n### 反射机制\n\n#### 作用\n\n1. 在运行时判断任意对象所属的类\n2. 在运行时构造任意类的对象\n3. 在运行时得到任意类的成员变量和方法\n4. 在运行时调用任意对象的成员变量和方法\n5. 生成动态代理\n\n#### 相关类\n\n主要类\n\n- Class：Class对象表示某个类加载后在队中的对象\n- Method：Method对象代表某类的方法\n- Field：Field对象代表类的成员变量\n- Constructor：Constructor对象代表类的构造方法\n\n在反射的机制中所有类的组成部分都被封装为对应的对象\n\n- 如：方法对象、属性对象、构造器方法对象等\n\n#### 效率优化\n\nsetAccessible()方法：\n\n- Method和 Field 、Constructor对象都有setAccessible()方法\n- 该方法作用是启动和禁用访问安全检查的开关\n- 参数\n 	 - true：表示反射的对象在使用时取消访问检查，提高效率；\n 	 - false：表示反射的对象执行访问检查\n\n实际上优化效果很有限\n\n### Class类\n\n- Class类也是一个类，继承Object类\n- Class类对象不是new出来的，而是系统创建；在加载类的时候创建，存放在堆中\n- 类的字节码二进制数据是存放在方法区（类的元数据：包括 方法代码、变量名、方法名、访问权限等）（在加载类时生成）\n- 对于某个类的Class类对象在内存中只有一份，因为类只加载一次\n- 每个类的实例都会记得是由哪个Class实例生成\n- 通过 Class 可以通过一系列API得到一个类的完整结构\n\n![Class主要类类结构](/resources/Images/image-20220114215252246.png)\n\n#### 对象实例化方式\n\n##### getClass() 方法\n\n- Object 类中 有 getClass() 方法\n- 必须先产生指定类对象，再通过getClass()方法回去该类Class对象\n\n```java\nTest test = new Test();\nClass<? extends Test> aClass = test.getClass();\nSystem.out.println(aClass);\n//输出结果: class demo03.Test		：该类的全路径\n```\n\n##### 类名.class\n\n- JVM可以直接支持获得\n- 但是必须要导入使用的程序类所在包\n\n```java\nClass<Test> aClass = Test.class;\nSystem.out.println(aClass);\n//输出结果: class demo03.Test\n```\n\n##### Class 类支持\n\nClass 类中的静态方法\n\n- `public static Class<?> forName(String className) throws ClassNotFoundException`\n- 可以采用字符串形式定义要使用的类型，且无需导包\n- 但使用的程序类若不存在会抛出异常 `ClassNotFoundException`\n\n```java\n//传入要使用的类的全路径\nClass<?> aClass = Class.forName(\"demo03.Test\");\nSystem.out.println(aClass);\n//输出结果: class demo03.Test\n```\n\n#### 常用方法\n\n![Class类常用方法](/resources/Images/image-20211122153211074.png)\n\n#### 拥有Class对象\n\n1. 类（外部类和内部类）\n2. interface接口\n3. 数组\n4. enum枚举\n5. annotation注解\n6. 基本数据类型\n7. void\n\n### 反射使用\n\n![反射结构类图](/resources/Images/4dd2ed7e67664e6d962a0b0550cac9c1.png)\n\n- 程序类 Person，继承 抽象类 AbstractBase，实现两个接口\n- 通过 Person.class 获取Class 对象\n- 通过 Class 对象 getPackage() 方法获取 Package 对象\n- 也可以获取 Constructor、Method、Filed对象\n	 - Constructor、Method 继承 Executable 继承 AccessibleObject\n 	 - 最早期Construtor、Method、Filed都是 AccessibleObject 直接子类\n\n#### 通过反射获取类的结构信息\n\n- java.lang.Class类\n\n	- ![java.lang.Class类](/resources/Images/image-20211123094644333.png)\n\n- java.lang.Field类\n\n  	- ![java.lang.Field类](/resources/Images/image-20211123094759842.png)\n\n- java.lang.Method类\n	- ![java.lang.Method类](/resources/Images/image-20211123095236874.png)\n\n- java.lang.Constructor类\n\n	- ![java.lang.Constructor类](/resources/Images/image-20211123095738594.png)\n\n#### 创建对象\n\n1. 调用类中的public修饰的无参构造器\n2. 调用类中指定的构造器\n\nClass类中方法：\n\n- newInstance()\n\n  	- 调用类中的无参构造器，获取对应类的对象\n 	 - JDK9使用 `getDeclaredConstructor().newInstance();`\n\n```java\n  //等价于 Test test = new Test();\n  try {\n      //加载 Test 的Class类对象\n      Class<?> aClass = Class.forName(\"demo03.Test\");\n      //获取实例化对象\n      Object o = aClass.getDeclaredConstructor().newInstance();\n      //向下转型\n      Test test = (Test)o;\n  	} catch (ClassNotFoundException |\n               NoSuchMethodException | InstantiationException |\n               IllegalAccessException | InvocationTargetException e) {\n              e.printStackTrace();\n  		}\n```\n\n- getConstructor(Class...clazz)\n\n  	- 根据参数列表获取对应的公开的构造器\n  	- 不传参即为无参构造器\n  	- 虽然允许调用有参构造，但实际开发使用反射的类最好提供无参构造实例化达到统一性\n\n- getDeclaredConstructor(Class...clazz)\n\n  	- 根据参数列表获取对应的所有构造器（包括私有构造）\n\nConstructor类相关方法\n\n- setAccessible(true)\n  	- 爆破（暴力破解，强行访问私有构造器）\n- newInstance(Object...obj)\n  	- 调用构造器，使用时等价于 new\n  	- 传入对应构造器参数类型参数进行有参构造\n    	- 不传参默认无参构造\n    	- 参数有与否 与 获取的构造器保持一致\n  	- 因为默认的Class类中的 newInstance() 只能调用无参构造。所以认为其描述不准确，因此不再推荐直接使用\n\n#### 获取类基本信息\n\n##### 类结构\n\n获取包\n\n- 获取包对象\n  	- `pbulic Package getPackage()`\n- 获取包名称\n  	- `public String getPackageName()`\n  	- 或 `package.getName()`，package：获取到的包结构\n\n获取继承父类\n\n- `public Class<? super T> getSuperclass()`\n\n获取实现父接口\n\n- `public Class<?>[] getInterfaces()`\n\n##### 方法\n\n- 根据方法名和参数列表获取Method方法对象\n  	- Method m = class对象.getDeclaredMethod(方法名，XX.class）\n    	- 获取普通方法对象\n    	- 传入方法名 和 方法对应的参数类型的Class对象\n  	- Object o = class对象.getDeclaredConstructor().newInstance()；\n    	- 获取构造方法对象，并实例化对象\n    	- 不传入参数默认调用无参构造\n- 获取方法对象\n  	- `public Method[] getMethods()`\n    	- 获取全部公有方法（包括父类）\n  	- `public Metnod getMethod(String name, Class<?>...paraTypes)`\n    	- 获取指定公有方法（包括父类）\n    	- 传入方法名 和 参数类型的 Class对象\n  	- `pbulic Method[] getDeclaredMethods()`\n    	- 获取本类所有方法（所有权限类型）\n  	- `public Methos getDeclaredMethos(String name, Class<?> par)`\n    	- 获取本类指定方法（所有权限类型）\n    	- 传入方法名 和 参数类型的 Class对象\n- 爆破：m.setAccessible(true);\n- 访问：Object returnValue = m.invoke(obj, 实参列表)\n  	- 对于静态方法，参数 obj 可为null\n  	- 反射调用执行类中方法\n\n```java\npublic class Test{\n    private String name;\n    public void setName(String name){\n        this.name = name;\n    }\n    public String getName(){\n        return name;\n    }\n    public static void main(String[] args) {\n        try {\n            //反射获取 Test 类 Class 对象\n            Class<?> a = Class.forName(\"demo03.Test\");\n            //反射调用无参构造获取实例化对象\n            Object o = a.getDeclaredConstructor().newInstance();\n            //反射获取 setName() 方法\n            Method setName = a.getDeclaredMethod(\"setName\", String.class);\n            //反射执行 setName() 方法\n            setName.invoke(o, \"张三\");\n            //反射获取 getName() 方法\n            Method getName = a.getDeclaredMethod(\"getName\");\n            //反射执行 getname() 方法\n            System.out.println(getName.invoke(o));\n        } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n##### 属性\n\n- 根据属性名获取Field对象\n  	- Field field = class对象.getDeclaredField(属性名);\n  	- Object obj = class对象.getDeclaredConstructor().newInstance()；\n    	- 调用构造方法实例化对象\n- 获取属性对象\n  	- `public Filed[] getFileds()`\n    	- 获取所有公有属性（包括父类）\n  	- `pbllic Filed getFiled(String name)`\n    	- 获取指定公有属性（包括父类）\n    	- 传入属性名，必须是公有属性\n  	- `public Filed[] getDeclaredFields()`\n    	- 获取本类所有属性（所有权限类型）\n  	- `public Filed getDeclaredField(String name)`\n    	- 获取本类指定属性（所有权限类型）\n    	- 传入属性名，必须是本类属性\n- 爆破：field.setAccessible(true)\n- 访问\n  	- filed.getType()\n    	- 获取属性类型对象\n	- filed.getType().getName()\n      	- 获取属性类型名称（全名称）\n	- filed.getType().getSimpleName()\n      	- 获取树形类型名（只有类型名）\n  	- field.set(obj, value)\n    	- 设置属性值\n    	- 传入实例对象 和 参数值\n  	- field.get(obj)\n    	- 获取属性值对象\n    	- 传入实例对象\n  	- 如果是静态属性则参数 obj 可为 null\n	- 实际开发大多属性设置操作使用getter、setter方法\n  	- 开发中常用Filed 与 Method 类实现类中 setter、getter方法调用\n\n```java\npublic class Test extends D{\n    private String name;\n    public static void main(String[] args) {\n        try {\n            Class<?> a = Class.forName(\"demo03.Test\");\n            //反射获得实例化对象\n            Object obj = a.getDeclaredConstructor().newInstance();\n            //反射获得 name 属性对象\n            Field name = a.getDeclaredField(\"name\");\n            //取消该属性安全检查，可以访问该私有属性\n            name.setAccessible(true);\n            //为实例化对象 obj 的 name 属性设置参数 张三\n            name.set(obj, \"张三\");\n            //获取实例化对象 obj 的 name 属性值\n            System.out.println(name.get(obj));\n        } catch (ClassNotFoundException | NoSuchFieldException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n#### Unsafe 工具类\n\n主要特点\n\n- 可利用发射获取对象，且直接使用底层的 C++ 来代替 JVM 执行\n 	 - 即绕过JVM的相关对象管理机制\n\n最大特征：绕过实例化对象管理\n\n构造： `private Unsafe(){}`\n\n私有常量：`private static final Unsafe theUnsafe = new Unsafe();`\n\n- 但该类没有 static 方法，即不能通过传统类似单例模式方式获取实例对象\n- 必须利用反射机制获取实例化对象\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            //反射获取 Unsafe 类私有静态属性 theUnsafe； Unsafe：内部实例化对象属性\n            Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            //爆破私有属性访问权限\n            theUnsafe.setAccessible(true);\n            //获取实例化对象\n            Unsafe unsafe = (Unsafe)theUnsafe.get(null);\n            //通过 Unsafe 对象 获得单例类实例化对象\n            	/*\n            	相当于利用 Unsafe 类绕过 JVM 的管理机制，在没有实例化对象的情况下获取 单例类的实例化对象\n            	*/\n            Single single = (Single)unsafe.allocateInstance(Single.class);\n            single.print();\n        } catch (NoSuchFieldException | IllegalAccessException | InstantiationException e) {\n            e.printStackTrace();\n        }\n    }\n}\n/*\n单例设计程序类\n*/\nclass Single{\n    //仅有私有无参构造，不提供静态方法获取本类实例化对象\n    private Single(){}\n    public void print(){\n        System.out.println(\"反射使用单例测试\");\n    }\n}\n```\n\nUnsafe只是为开发提供了些更加方便的处理机制\n\n- 但这种操作不受JVM操作管理\n- 非必需情况下不建议使用\n\n### 属性赋值\n\n#### 传统属性赋值\n\n传统开发：产生对象后调用方法\n\n- 实例化对象\n- 调用 setter 方法赋值\n  	- 少量属性时使用 构造器 赋值比较方便\n  	- 传统开发一般使用 setter 方法赋值\n- 对于大量属性赋值（例如50个以上）会大量调用setter方法\n\n实际开发中存在大量简单Java类\n\n- 对于大量 简单Java类属性赋值\n- 使用传统的直观编程方式，代码会存在大量重复操作\n- 解决对象的重复操作问题的唯一方案是反射机制\n  	- 根据自身特点实现相同功能类的重复操作的抽象处理\n  	- 特点：Object类直接操作，可以直接操作属性或方法\n\n#### 属性自动赋值\n\n**使用字符串形式描述对应类型**\n\n- 程序开发时，String字符串可以描述很多内容，并且可以自行定义字符串结构\n  	- 例：\"属性名内容\" 格式 为简单Java类属性初始化\n  	- 格式：属性名:内容|属性名:内容\n- 字符串使用户键盘输入数据提供，获取数据后发现数据可以进行分解\n  	- 分解后获得属性名和对应属性值\n  	- `ename:Simth|job:Clerk`\n  	- ename：属性名，Smith：要赋值的内容 等\n- 通过属性名可以获得Java类中属性类型和相关方法\n  	- Filed 类获取属性对象，得到属性类型\n  	- Method 类获取相关方法：setter、getter\n  	- 最终将属性值赋值到对象属性\n- 想实现以上操作，需要使用 Class 类\n  	- 通过 Class 找到 Field、Method 等相关类和方法\n  	- 通过字符串操作持续使用反射即可获取信息\n 	- 但直接如此操作十分麻烦\n- 类设计基本结构\n  	- 由专门的 工具类 负责所有反射处理\n  	- 即：接收 反射对象 与 属性值，同时获取执行类的实例化对象\n\n```java\n//设置属性值并获取实例对象的工具类\nclass FactoryUtil {\n    private FactoryUtil() {}\n    /**\n     * 进行反射操作\n     * 根据传入的字符串结构实例化对象：\"属性名:属性值|属性名:属性值\"\n     *\n     * @param clazz 要实例化的Java类\n     * @param value 按规定格式输入的字符串\n     * @return 返回配置好属性内容的Java类对象\n     */\n    public static <T> T create(Class<?> clazz, String value) {\n        try {\n            //Java类中必须有无参构造，否则无法进行；此时出现错误即使抛出异常也无效\n            Object o = clazz.getDeclaredConstructor().newInstance();\n            //反射进行对象属性赋值\n            BeanUtil.setValues(o, value);\n            //为对象进行转型\n            return (T) o;\n        } catch (InstantiationException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n```\n\n##### 单级属性设置\n\n###### 单级属性\n\n- 本类给出的数据类型都没有其他引用关联\n  	- 即本类属性不属于其他类对象\n- 仅描述本类的对象\n\n对于单级设置\n\n1. 通过反射进行指定类对象的实例化处理\n2. 进行内容的设置\n   	- 获取 Filed属性类型、方法名称、属性值\n   	- 为多种类型属性赋值\n3. 完善工具类之后即使类中有诸多属性也可轻松实现setter调用和类实例化处理\n\n###### 示例\n\n简单实现单击属性设置\n\n```java\npackage demo03;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n// 简单Java类\npublic class Test {\n    private String name;\n    private int age;\n    private Date date;\n    public void setDate(Date date){ this.date = date; }\n    public Date getDate(){ return date }\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    public int getAge() { return age; }\n    public void setAge(int age) { this.age = age; }\n    @Override\n    public String toString() {\n        return \"姓名: \" + name + \"\\tage: \" + age + \"\\t\\t当前时间: \" + date; \n    }\n    public static void main(String[] args) {\n        String value = \"name:张三|job:经理|date:15654\";\n        Test test = FactoryUtil.create(Test.class, value);\n        System.out.println(test);\n    }\n}\n\n//通过反射处理为对象赋值并获取实例对象的工具类\nclass FactoryUtil {\n    private FactoryUtil() {}\n\n    /**\n     * 进行反射操作\n     * 根据传入的字符串结构实例化对象：\"属性名:属性值|属性名:属性值\"\n     * @param clazz 要实例化的Java类\n     * @param value 按规定格式输入的字符串\n     * @return 返回配置好属性内容的Java类对象\n     */\n    public static <T> T create(Class<?> clazz, String value) {\n        try {\n            //Java类中必须有无参构造，否则无法进行；此时出现错误即使抛出异常也无效\n            Object o = clazz.getDeclaredConstructor().newInstance();\n            //反射进行对象属性赋值\n            BeanUtil.setValues(o, value);\n            //为对象进行转型并返回\n            return (T) o;\n        } catch (InstantiationException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n\n//对对象属性赋值的工具类\nclass BeanUtil {\n    private BeanUtil() {}\n\n    /**\n     * 通过反射对对象属性赋值\n     * @param obj 实例对象\n     * @param value 规定格式字符串：”属性名:属性值|属性名:属性值“\n     */\n    public static void setValues(Object obj, String value) {\n        //按 \"|\" 对字符串进行拆分为不同属性字段\n        String[] split = value.split(\"\\\\|\");\n        for (String s : split) {\n            //按照 \":\" 再次进行拆分,fields[0]是属性名，fields[1]是属性值\n            String[] fields = s.split(\":\");\n            try {\n                //反射通过属性名获得该属性的对象\n                Field field = obj.getClass().getDeclaredField(fields[0]);\n                //拼写该属性的 setter 方法名\n                String fieldName = \"set\" + StringUtil.upStarFirst(fields[0]);\n                //反射通过方法名获得该属性的 setter 方法对象\n                Method setValue = obj.getClass().getDeclaredMethod(fieldName, field.getType());\n                //将属性值类型转为对应属性类型,进行多种属性类型设置\n                Object fieldValue = changeType(field.getType().getName(), fields[1]);\n                //反射执行 setter 方法为 obj对象 属性赋值\n                setValue.invoke(obj, fieldValue);\n            } catch (NoSuchFieldException | NoSuchMethodException \n                     | IllegalAccessException | InvocationTargetException e) { \n                //捕捉到异常此项属性暂不处理，继续进行下一项属性赋值\n            }\n        }\n    }\n\n    /**\n     * 将属性值转换为对应属性类型\n     * @param type 属性类型\n     * @param value 属性值\n     * @return 返回转换类型后的属性值\n     */\n    public static Object changeType(String type, String value){\n        if (\"long\".equals(type) || \"java.long.Long\".equals(type)) {\n            return Long.parseLong(value);\n        }else if (\"int\".equals(type) || \"java.long.Integer\".equals(type)) {\n            return Integer.parseInt(value);\n        }else if (\"double\".equals(type) || \"java.long.Double\".equals(type)) {\n            return Double.parseDouble(value);\n        }else if (\"short\".equals(type) || \"java.long.Short\".equals(type)) {\n            return Short.parseShort(value);\n        }else if (\"float\".equals(type) || \"java.long.Float\".equals(type)){\n            return Float.parseFloat(value);\n        } else if (\"java.util.Date\".equals(type)) {\n            SimpleDateFormat simple = null;\n            if (value.matches(\"\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}\")) {\n                simple = new SimpleDateFormat(\"yyyy-MM-dd\");\n            } else if (value.matches(\"\\\\d{4}-\\\\d{1,2}-\\\\d{1,2} \\\\d{2}:\\\\d{2}:\\\\d{2}\")) {\n                simple = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n            } else {\n                return new Date();\n            }\n            try {\n                return simple.parse(value);\n            } catch (ParseException e) {\n                return new Date();\n            }\n        }\n        return value;\n    }\n}\n//处理属性名首字母大写的工具类\nclass StringUtil {\n    private StringUtil() {}\n\n    /**\n     * 将属性名首字母变为大写\n     * @param name 属性名\n     * @return 返回首字母大写的属性名\n     */\n    public static String upStarFirst(String name) {\n        if (\"\".equals(name) || name == null) {\n            return name;\n        }\n        if (name.length() == 1) {\n            return name.toUpperCase();\n        } else {\n            return name.substring(0, 1).toUpperCase() + name.substring(1);\n        }\n    }\n}\n```\n\n##### 多级属性赋值\n\n###### 多级设置\n\n简单Java类对象中存在其他引用的级联关系，称为多级设置\n\n- 例如：雇员属于部门，部门属于公司\n\n```java\n  class Company{\n      private String cname;\n      //属性方法略\n  }\n  class Dept{\n      private String dname;\n      private Company company;//部门属于一个公司\n      //其他属性方法略\n  }\n  class Emp{\n      private String ename;\n      private Dept dept;//员工属于一个部门\n      //其他属性方法略\n  }\n```\n\n- 使用雇员表进行级联属性设置时通过`.`\n\n  	- 例如：dept.dname，调用部门表的部门名称\n    	- emp实例化对象.getDept().setDname(\"财务部\")\n    	- 级联设置部门名称\n  	- dept.company.cname，调用公司名称\n    	- emp实例对象.getDept().getCompany().setCname(\"小米\")\n    	- 级联设置公司名称\n  	- 调用级联属性对象时要保证调用对象（dept、company）已实例化\n    	- 可在简单Java类中定义属性时直接实例化，但代码冗杂\n    	- 为代码的简洁性，通过级联配置自动实现类中属性实例化\n    	- 属性中存在级联关系，多级的关系就必须与单级配置分开\n\n###### 示例\n\n相对于单级属性设置反射\n\n- 在工具类仅修改 setValue() 方法\n- 在简单 Java 中添加对应 级联属性 和 setter、getter 方法\n\n```java\n/**\n* 通过反射对对象属性赋值\n* @param obj 实例对象\n* @param value 规定格式字符串：”属性名:属性值|属性名:属性值“\n*/\npublic static void setValues(Object obj, String value) {\n    //按 ”|“ 对字符串进行拆分为不同属性字段\n    String[] split = value.split(\"\\\\|\");\n    for (String s : split) {\n        //按照 ”:“ 再次进行拆分,fields[0]是属性名，fields[1]是属性值\n        String[] fields = s.split(\":\");\n        //判断是否有级联对象（是否存在 \".\"）\n        if (fields[0].contains(\".\")) {\n            //按照 . 拆分，最后一部分为属性名，前面部分为级联属性\n            String[] temp = s.split(\"\\\\.\");\n            //将调用对象赋给当前对象\n            Object currentObj = obj;\n            for (int i = 0; i < temp.length - 1; i++) {\n                try {\n                    //获取级联属性的 get 方法\n                    Method getMethod = currentObj.getClass().getDeclaredMethod(\"get\" + StringUtil.upStarFirst(temp[i]));\n                    //执行 get 方法得到该级联对象\n                    Object tempObject = getMethod.invoke(currentObj);\n                    if(tempObject == null){\n                        //得到该属性对象，用来获取属性类型（级联对象类）\n                        Field field = currentObj.getClass().getDeclaredField(temp[i]);\n                        //该级联对象为空，得到该属性set方法\n                        Method setMethod = currentObj.getClass().getDeclaredMethod(\"set\" + StringUtil.upStarFirst(temp[i]), field.getType());\n                        //创建该级联属性的对象\n                        Object newObject = field.getType().getDeclaredConstructor().newInstance();\n                        //执行 set 方法将 将级联对象封装到级联属性\n                        setMethod.invoke(currentObj, newObject);\n                        //将该级联对象赋给当前对象（还有下一级级联属性时用来实例化对象）\n                        currentObj = newObject;\n                    }else {\n                        //当前该级联属性已存在级联对象，直接赋给当前对象（还有下一级联属性时继续实例化对象）\n                        currentObj = tempObject;\n                    }\n                } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) {\n                    //e.printStackTrace();\n                }\n            }\n            //递归调用将属性值赋值\n            setValues(currentObj, temp[temp.length -1]);\n        } else {\n            try {\n                //反射通过属性名获得该属性的对象\n                Field field = obj.getClass().getDeclaredField(fields[0]);\n                //拼写该属性的 setter 方法名\n                String fieldName = \"set\" + StringUtil.upStarFirst(fields[0]);\n                //反射通过方法名获得该属性的 setter 方法对象\n                Method setValue = obj.getClass().getDeclaredMethod(fieldName, field.getType());\n                Object fieldValue = changeType(field.getType().getName(), fields[1]);\n                //反射执行 setter 方法为 obj对象 属性赋值\n                setValue.invoke(obj, fieldValue);\n            } catch (NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n                //捕捉到异常此项属性暂不处理，继续进行下一项属性赋值\n            }\n        }\n    }\n}\n```\n\n### 反射 与 Annotation\n\nJDK 1.5 之后Java开发提供了 Annotation 技术支持\n\n- 为项目编写带来新的模型，所有开发中都存在\n\n#### 注解\n\n```java\n@Interface	//注解类，有这个关键字的表明后跟一个注解类\n@Override	//只能写在方法上面表明为重写的方法，可以检查代码格式\n@Deprecated	//表示被注解的方法或类已过时，但仍可以继续使用、\n@SuppressWarnings	//抑制编译器的警告\n	/*\n	可用在类上面作用于整个类，或方法上面作用于这个方法，或用于语句上精准抑制\n	用法: @SuppressWarnings({\"unchecked\",\"unnuse\"})：传入字符串数组格式\n	*/\n//元注解，解释注解的注解,四种元注解\n@Target		//表明该注解可用的的作用域\n@Retention	//表明注解生效的时段\n@Documented	//指定被修饰的注解类将被javadoc工具提取成文档，即在生成文档时可以看到\n@Inherited	//表明将具有继承性，子类会继承父类使用的该注解\n```\n\n![注解抑制](/resources/Images/image-20211031222159666-16458662082583.png)\n\n#### 获取Annotation信息\n\n- 进行类或方法定义的时候可以使用一系列的 Annotation 进行声明\n\n- 可以通过反射直接获取这些 Annotation 信息\n\n  - java.lang.reflect 中有 AccessibleObject 类提供获取方法\n\n```java\n//获取全部Annotation\npublic Annotation[] getAnnotations();\n//获取指定Annotation\npublic <T extends Annotation> T getAnnotation(Class<T> a) \n```\n\n- 获取后都返回 Annotation 对象\n\n	- Annotation 是 JDK1.5 之后的接口\n\nAnnotation的读取操作\n\n- Annotation 有存在范围\n\n  	- `@Functionalinterface`在运行时生效\n    	- 程序执行时可获取\n  	- `@AuppressWaring`在源代码编写时有效\n  	- 枚举类 `RetentionPolicy`中有 class 定义：表示在类定义时生效\n\n```java\n//Annotation 生效时段定义 枚举类\npublic enum RetentionPolicy {\n	SOURCE,\n	//在源代码编译时生效（.java文件）；不保存注释\n	CLASS,\n	//类定义时生效（.class文件）；记录在类文件，运行时JVM不保存\n	RUNTIME\n	//运行时生效；记录在类文件，运行时由JVN保存，所以可被反射读取\n}\n```\n\n#### 自定义Annotation\n\n使用 `@interface`定义 Annotation\n\n使用 Annotation 最大特点就是可以结合反射机制实现程序的处理\n\n```java\n@Retention(RetentionPolicy.RUNTIME) //定义该注解生效\n//定义注解类\n@interface People {\n    //定义注解参数方法\n    String name(); //获取数据\n    int age() default 18;//获取数据，默认值 18\n}\n\npublic class Test {\n    @People(name = \"张三\")//使用注解，没有默认值需要传入数据\n    public void send(String name, int age) {\n        System.out.println(name + \"今年\" + age + \"岁\");\n    }\n\n    public static void main(String[] args) {\n        try {\n            Class<Test> obj = Test.class;\n            //反射获取 Test 类 send 方法对象\n            Method send = obj.getDeclaredMethod(\"send\", String.class, int.class);\n            //反射指定获取 People 注解类对象\n            People annotation = send.getAnnotation(People.class);\n            //反射获取Test 类对象\n            Objecct test = obj.getDeclaredConstructor().newInstance(), annotation.name();\n            //反射执行 send 方法，参数为 注解中的数据\n            send.invoke(test, annotation.age());\n            System.out.println(annotation.age());\n            System.out.println(annotation.name());\n        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### Annotation 与 工厂设计模式\n\n简单实现动态工厂、动态代理与 Annotation结合\n\n```java\n//自定义注解类，获取接口子类信息\n@Retention(RetentionPolicy.RUNTIME)\n@interface People {\n    Class<?> clazz();\n}\n//业务接口\ninterface Message {\n    void send(String mes);\n}\n//接口实现子类\nclass MessageImpl implements Message {\n    public void send(String mes) {\n        System.out.println(\"废物\" + mes);\n    }\n}\n//动态代理类\nclass Demo implements InvocationHandler {\n    //封装接口实例\n    private Object target;\n\n    //找到接口实现子类并绑定，伪造该实现子类的对象\n    public Object find(Object target) {\n        this.target = target;\n        return Proxy.newProxyInstance(this.target.getClass().getClassLoader(), this.target.getClass().getInterfaces(), this);\n    }\n\n    //执行该实现子类的方法\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Object invoke = null;\n        if (target != null) {\n            invoke = method.invoke(target,args);\n        }\n        return invoke;\n    }\n}\n//动态工厂类\nclass Factory {\n    private Factory(){}\n    //获取实例对象\n    public static <T>T getInstance(Class<T> clazz){\n        try {\n            //通过动态代理类获取实例对象\n            return (T)new Demo().find(clazz.getDeclaredConstructor().newInstance());\n        } catch (InstantiationException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n//发送消息业务类\n//注解存放要实现的接口实例 Class 对象\n@People(clazz = MessageImpl.class)\nclass MessageService{\n    private Message message;\n    public MessageService(){\n        //通过注解获取要使用的接口实例 Class 对象，并封装到属性\n        People annotation = MessageService.class.getAnnotation(People.class);\n        this.message = (Message) Factory.getInstance(annotation.clazz());\n    }\n    public void send(String mes){\n        //调用实际子类的方法执行\n        this.message.send(mes);\n    }\n}\npublic class Test{\n    public static void main(String[] args) {\n        new MessageService().send(\"点心\");\n    }\n}\n```\n\n\n\n## 反射与设计模式\n\n#### 工厂设计模式\n\n工厂模式最大特点：\n\n- 客户端程序不直接牵扯到对象的实例化管理，只与接口发生关联\n- 通过工厂类获取指定接口的实例化对象\n\n使用工厂模式：\n\n- 实际开发中接口主要为不同层提供操作标准\n- 若直接将一个子类设置实例化操作一定会有耦合问题\n- 所以使用工厂设计模式解决此问题\n- 工厂模式最有效解决的是子类与客户端的耦合问题\n  	- 核心思想在于提供工厂类作为过渡端\n\n##### 静态工厂设计模式\n\n- 传统工厂设计在接口追加新的子类时必须修改工厂类\n- 否则无法获取追加子类的实例化对象\n- 此时最好的解决方式是不使用 new\n\n##### 反射进行工厂设计\n\n- 使用反射机制实现工厂模式最大优势在于对接口子类的扩充不再将影响到工厂类的定义\n- 对于大量接口使用工厂类获取实例化对象\n  	- 此时工厂类应该变为向所有接口提供服务\n  	- 应添加泛型约束\n  	- 此时工厂不再受限于指定接口，可以为所有接口提供实例化\n\n```java\npackage demo03;\npublic class Test{\n    public static void ma\n        in(String[] args){\n        Test test = Factory.getInstance(\"demo03.Test\", Test.class);\n        System.out.println(test.getClass());\n    }\n}\n class Factory{\n    private Factory(){};//工厂类没有产生实例化对象的意义\n    //传入要获得的子类的全路径，以及该类的Class对象以确定返回的实例该类型\n    public static <T> T getInstance(String className, Class<T> clazz){\n        T instance = null;\n        try{\n            //利用反射获取该接口实例化对象，即使接口追加新的子类也不需要修改工厂类\n            instance = (T)Class.forName(className).getDeclaredConstructor(). newInstance();\n        }catch(Exception e){\n            throw new RuntimeException(e);\n        }\n        return instance;\n    }\n}\n```\n\n#### 代理设计模式\n\n代理设计模式是在程序开发中使用最多的设计模式\n\n核心：真实业务实现类与代理业务实现类\n\n- 代理类完成比真是业务更多的处理操作、\n\n##### 静态代理设计\n\n即传统代理模式\n\n特点：一个代理类只为一个接口服务\n\n- 但若有多接口则需要编写多个代理类，且代理类操作形式类似\n- 需要实现以一个接口满足所有业务接口\n\n弊端：所有代理设计模式按照设计要求必须是基于接口设计\n\n- 即：先定义出核心接口的组成\n- 客户端的接口与具体子类产生耦合\n  	- 具体开发可以引入工厂设计模式进行代理对象获取\n\n#####   动态代理设计\n\n一个代理类代理多个业务接口\n\n- 为所有功能一致的业务操作接口提供统一的代理处理操作\n- 通过动态代理机制实现\n\n###### 处理\n\n- 动态代理类 和 静态代理类 都一定要接收真实业务实现子类对象\n  	- 程序处理过程中要保证能接收 所有 真实业务处理子类\n  	- Object 类接收\n- 动态代理类不再与某一具体接口捆绑\n  	- 所以应该可以动态获取类的接口信息\n- 动态代理返回给客户端接口代理对象，但代理类不和任何接口关联\n  	- 获取所有有可能用到的接口操作对象（通过反射）\n    	- `obj.getClass().getInterfaces()`\n	- 客户端想正常处理执行通过接口代理对象\n		- 通过反射接口获得\n	- 取得接口对象后有专门的系统类\n	    - 根据接口对象和传过来的操作信息做出自己的接口代理对象\n    	- 客户端通过代理对象操作时本质上是在操作接口对象\n  - InvocationHandler 接口\n	- 实现在开发中的代理方法控制\n    - 规定了代理方法的执行\n    - 因为跨越多个接口，所以方法名由程序定义\n\n```java\n public interface InvocationHandler {\n /**\n * 代理方法的调用，代理主体类里执行的方法都是此方法\n * @param proxy 要代理的对象\n * @param method 要执行的接口方法名称\n * @param args 传递的参数\n * @return 某一个方法的返回值\n * @throws Throwable 方法调用时出现的错误继续向上抛\n */\n public Object invoke(Object proxy, Method method, Object[] args)\n 	throws Throwable;\n}\n```\n\n![动态代理执行流程](/resources/Images/820a7ce1f161424b86c98be4c9064b6c.png)\n\n###### 代理方法\n\n- 进行动态代理设计\n\n- 动态对象的创建由 JVM 底层完成\n\n  - 主要依靠 java.lang.reflect.Proxy 程序类\n\n```java\n    /**\n    *\n    * @param loader 获取当前真实主体类 ClassLoader 加载器\n    * @param interfaces 真实主体类的 接口信息\n    * @param h 代理处理的方法\n    * @return 返回伪造的业务接口子类实例对象\n    */\n    public static Object newProxyInstance(ClassLoader loader, Clss<?>[] interfaces, InvocationHandler h);\n```\n\n- `Proxy.newProxyInstance()`\n	- 使用大量底层机制进行动态代理对象的动态创建\n	- 所有代理类是复合所有相关功能具体需求的操作功能类\n		- 不再代表具体接口\n		- 必须依赖主类的类加载器与接口进行代理对象的伪造\n\n- 代理操作关键\n	- InvocationHandle\n  	- 核心类 Proxy\n\n![代理方法执行流程](/resources/Images/ec1421317baa4eaea35778726338f979.png)\n\n- 代理方法执行流程\n  	1. 主类操作时接收业务的是真实实现类\n		- Proxy 根据真实业务类创建代理对象\n  	2. 主类通过 Proxy 返回的代理对象操作\n		- 代理对象特征：复合业务接口结构\n  	3. 代理对象调用时 找到 InvocationHandler 类的 invoke()方法\n		- 代理对象调用方法会找到invoke()\n     	- invoke()调用业务接口（业务接口实现子类）的方法，\n\n###### 示例\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        //创建代理类对象并传入业务接口实例对象，通过 find() 方法找到伪造的业务接口实例对象\n        Message message = (Message) new DemoProxy().find(new MessageImpl());\n        //执行业务接口中方法（实际通过 InvocationHandler 接口中 invoke 方法调用接口子类中方法）\n        message.send();\n        System.out.println(\"运行类型: \" + message.getClass().getName());\n        //运行类型: demo03.$Proxy0 ；所以返回的只是伪造的业务子类对象\n        /*\n        另一组测试接口、实例\n        A a = (A) new DemoProxy().find(new B());\n        a.a();\n        System.out.println(\"运行类型: \" + a.getClass().getName());\n        //运行类型: demo03.$Proxy1\n        */\n    }\n}\n//动态代理类，可任意代理业务接口的实现子类\nclass DemoProxy implements InvocationHandler{\n    //封装可以接收任何接口实例对象的属性\n    private Object target;\n    //传入接口实例对象封装 Object 对象\n    public Object find(Object target){\n        this.target = target;\n        //利用系统类完成代理对象生成，并返回给客户端\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\n    }\n\n    //重写 Proxy 类中的 invoke 方法来执行业务接口子类中的方法\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Object obj = null;\n        if (target != null){\n            obj = method.invoke(this.target, args);\n        }\n        return obj;\n    }\n}\n//业务接口\ninterface Message{\n    void send();\n}\n//业务接口实现子类\nclass MessageImpl implements Message{\n    @Override\n    public void send() {\n        System.out.println(\"你好，废物\");\n    }\n}\n\n```\n\n', 'Java', '反射 基础', '1', 57, '1', '0', '2022-07-09 21:30:03', '2022-07-17 17:54:23', 0);
INSERT INTO `blog` VALUES (15, '二叉树', '### 二叉树\n---\n[TOCM]\n\n---\n\n#### 介绍\n\n链表结构开发中会发现所有数据按照首尾相连结构保存\n\n- 则进行数据查询时时间复杂度为 n（该数据所在位置）\n- 当数据量小（不超过 30）的时候没有太大差别\n  - 数据量变大之后时间复杂度就会非常损耗性能\n- 因此对数据存储结构要进行改变，尽可能减少检索次数\n  - 目前最好的性能：log(n)；因此使用二叉树实现\n\n#### 构造原理\n\n基本实现原理\n\n1. 取一个数据为保存的根节点\n\n2. 小于根节点的数据放在该节点的左子树\n\n   - 大于根节点的数据放在该节点的右子树\n\n   ![二叉树结构](/resources/Images/fe424c8e229e455ebe6465422de92f54.png)\n\n3. 进行数据检索的时候进行节点的判断\n\n   - 但判断是区分左右，即不进行整个结构的判断\n   - 此时时间复杂度是 log(n)\n\n#### 遍历\n\n获取数据有三种形式\n\n- 前序遍历：根、左、右\n- 中序遍历：左、根、右\n- 后序遍历：左、右、根\n\n#### 特点\n\n数据查询可以提供更好的查询性能\n\n- 但二叉树的结构有明显缺陷\n- 当二叉树的结构的改变的时候会出现不平衡的问题（增、删）、\n\n想达到最良好效果的查询结果是平衡二叉树\n\n- 同时所有节点的层次深度相同\n- 数据按照均衡二叉树进行保存则二叉树的检索效率一定最高\n  - 但还需要进行频繁的增加或删除操作，所以有进一步设计要求\n  - 红黑树\n\n![平衡二叉树](/resources/Images/495da59fe9074feda019b1f25f9f63ab.png)\n\n#### 传统二叉树基础实现\n\n二叉树处理中最关键问题在于数据保存\n\n- 由于数据牵扯到对象的比较需要比较器支持，首选 Comparable\n\n- 进行数据保存需要有节点类，封装 Comparable 属性数据 \n\n- 在进行数据添加时只是实现了节点关系的保存\n\n  - 这种关系保存使得所有数据保存后处于有序排列\n  - 在保存数据时已经进行了排序\n\n- 二叉树删除操作比较复杂\n\n  - 待删结点 A 无子节点 ：直接删\n\n  - 待删节点 B 只有一个字节点 ：直接删，并使用子节点代替它\n\n    - 将 B 的 子节点 的 父节点 改为 B 的父节点\n    - B 的父节点的左（或 右）节点设为 B 的子节点\n\n  - 待删节点 C 有两个子节点\n\n    - 要找出 C 的 后继节点\n    - 处理 后继节点 和 C 的父节点 之间关系\n      - C 节点右节点的最小左节点\n      - 或 C 节点左节点的最大右节点\n    - 处理 后继节点的子节点 和 C 的子节点 的关系\n\n    ![两个子节点删除](/resources/Images/b604bf4021ca48eaa88e586901cb82d2.png)\n\n- 这种数据结构的删除操作是非常繁琐的，非必须的情况不建议使用删除\n\n##### 二叉树简单实现代码\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BinaryTree<Person> tree = new BinaryTree<>();\n        tree.add(new Person(10));\n        tree.add(new Person(80));\n\n        Object[] persons1 = tree.toArray();\n        for (int i = 0; i < persons1.length; i++) {\n            Person person = (Person) persons1[i];\n            System.out.println(person);\n        }\n        System.out.println(\"总个数: \" + persons1.length);\n        tree.remove(new Person(10));\n        System.out.println(\"========删除后=========\");\n\n        Object[] persons2 = tree.toArray();\n        if (persons2 != null) {\n            for (int i = 0; i < persons2.length; i++) {\n                Person person = (Person) persons2[i];\n                System.out.println(person);\n                System.out.println(\"总个数: \" + persons2.length);\n            }\n        }else {\n            System.out.println(\"无数据\");\n        }\n    }\n}\n\n/**\n * 简单实现二叉树结构\n *\n * @param <T> 进行实现的比较\n */\nclass BinaryTree<T extends Comparable<T>> {\n    /**\n     * 内部类定义节点保存数据\n     */\n    private class Node {\n        private Comparable<T> data;     //传入要保存的对象数据，该类要实现了 Comparable 接口\n        private Node parent;    //父节点\n        private Node left;      //左节点\n        private Node right;     //右节点\n\n        public Node(Comparable<T> data) {\n            this.data = data;\n        }\n\n        /**\n         * 查找是否存在某个数据\n         *\n         * @param data 要查找的数据对象\n         * @return 找到返回 true，找不到返回 false\n         */\n        public boolean containsNode(Comparable<T> data) {\n            //当前节点就是要查找的节点\n            if (data.compareTo((T) this.data) == 0) {\n                return true;\n            }//当前节点大与要查找的节点，则递归查找当前节点左节点\n            else if (data.compareTo((T) this.data) < 0) {\n                if (this.left != null) {\n                    return this.left.containsNode(data);\n                } else {\n                    return false;\n                }\n            } //当前节点小于要查找节点，则递归查找当前节点右节点\n            else {\n                if (this.right != null) {\n                    return this.right.containsNode(data);\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        /**\n         * 得到被删除的数据对象\n         *\n         * @param data 要删除的数据对象\n         * @return 返回被删除的数据对象\n         */\n        public Node getRemoveNode(Comparable<T> data) {\n            //当前节点就是要删除的节点\n            if (data.compareTo((T) this.data) == 0) {\n                return this;\n            }//当前节点大于要删除的节点\n            else if (data.compareTo((T) this.data) < 0) {\n                if (this.left != null) {\n                    return this.left.getRemoveNode(data);\n                } else {\n                    return null;\n                }\n            }//当前节点小于要删除的节点\n            else {\n                if (this.right != null) {\n                    return this.right.getRemoveNode(data);\n                } else {\n                    return null;\n                }\n            }\n        }\n\n        /**\n         * 实现添加新节点\n         *\n         * @param newNode 传入的节点数据\n         */\n        public void addNode(Node newNode) {\n            if (newNode.data.compareTo((T) this.data) <= 0) { //新节点小于当前节点\n                //左节点为 null: 设为当前节点左节点，将新节点的父节点设为当前节点\n                if (this.left == null) {\n                    this.left = newNode;\n                    newNode.parent = this;\n                }\n                //当前节点左节点不为 null，递归调用本方法将当前节点的当节点作为当前根节点继续判断\n                else {\n                    this.left.addNode(newNode);\n                }\n            } else {      //新节点大于当前节点\n                //当前节点右节点为 null: 将当前节点右节点保存为新节点，新节点的父节点设为当前节点\n                if (this.right == null) {\n                    this.right = newNode;\n                    newNode.parent = this;\n                }\n                //当前节点右节点不为 null，递归调用本方法将当前节点的右节点作为当前根节点继续判断\n                else {\n                    this.right.addNode(newNode);\n                }\n            }\n        }\n\n        /**\n         * 实现二叉树结构遍历\n         * 中序遍历，先输出最左边的根节点的左节点，再输出当前根节点，在最后输出当前节点右节点\n         * 再进行父节点输出\n         */\n        public void toArrayNode() {\n            //当前节点左节点不为 null，递归调用本方法找到最左端的节点（即最小节点）\n            if (this.left != null) {\n                this.left.toArrayNode();\n            }//将该节点数据存入输出数据数组\n            BinaryTree.this.returnData[BinaryTree.this.index++] = this.data;\n            //当前节点右节点不为 null，递归调用本方法找到当前根节点最右侧节点\n            if (this.right != null) {\n                this.right.toArrayNode();\n            }\n        }\n\n    }\n\n    private Node root;  //根节点\n    private int count;  //保存数据个数\n    private Object[] returnData;    //返回数据数组\n    public int index;               //数组下标\n\n    /**\n     * 添加数据\n     *\n     * @param data 要添加的数据\n     */\n    public void add(Comparable<T> data) {\n        //传入空数据则报异常\n        if (data == null) {\n            throw new NullPointerException(\"保存数据不允许为空\");\n        }//将传入的数据封装到节点\n        Node newNode = new Node(data);\n        //当前根节点为 null 则直接将新节点数据保存在根节点\n        if (this.root == null) {\n            this.root = newNode;\n        }//若根节点不为bull 则调用节点添加新节点的方法进行保存\n        else {\n            this.root.addNode(newNode);\n        }\n        this.count++;   //保存数据之后数据个数 +1\n    }\n\n    /**\n     * 输出所有保存的数据\n     *\n     * @return 返回保存数据的对象数组\n     */\n    public Object[] toArray() {\n        //数据个数为 0 时直接返回 null\n        if (this.count == 0) {\n            return null;\n        }\n        // 数组下标初始化\n        this.index = 0;\n        //开辟对象数组，大小为当前数据个数\n        this.returnData = new Object[this.count];\n        //调用内部类方法将所有保存的数据存放进数组\n        this.root.toArrayNode();\n        return this.returnData;\n    }\n\n    /**\n     * 当前节点是否是其父节点的左节点\n     *\n     * @param node 传入的节点\n     * @return 返回结果\n     */\n    public boolean isLeft(Node node) {\n        if (node.data.compareTo((T) node.parent.data) > 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * 执行数据的删除处理\n     *\n     * @param data 要删除的数据\n     */\n    public void remove(Comparable<T> data) {\n        if (this.root == null) {  //根节点不存在，结束调用\n            return;\n        }\n        Node removeNode = this.root.getRemoveNode(data);//找到要删除的节点\n        if (removeNode != null) {//找到要删除的对象信息\n            //1: 没有任何的子节点\n            if (removeNode.left == null && removeNode.right == null) {\n                //如果只有根节点将根节点置空直接返回\n                if (removeNode == this.root){\n                    this.root = null;\n                    count --;\n                    return;\n                }\n                //待删节点是其父节点的左节点，断开父节点的左节点连接\n                if (isLeft(removeNode)) {\n                    removeNode.parent.left = null;\n                } else {\n                    removeNode.parent.right = null;\n                }\n                removeNode.parent = null;//断开该节点的父节点连接\n\n            }\n            //2: 只有一个左结点\n            else if (removeNode.left != null && removeNode.right == null) {\n                //删除节点是根节点，将左节点连接全部断开，并设为根节点\n                if (removeNode == this.root){\n                    this.root = removeNode.left;\n                    this.root.parent = null;\n                    removeNode.left = null;\n                    count--;\n                    return;\n                }\n                if (isLeft(removeNode)) {\n                    //当前节点 是 左节点 则将其左节点连接 其父节点的左节点\n                    removeNode.parent.left = removeNode.left;\n                } else {\n                    removeNode.parent.right = removeNode.left;\n                }\n                // 将左节点的父节点 设为当前节点的父节点\n                removeNode.left.parent = removeNode.parent;\n                //删除节点的 父节点 和 左节点置为 null\n                removeNode.parent = null;\n                removeNode.left = null;\n            }  // 只有一个右节点\n            else if (removeNode.left == null) {\n                //删除节点是根节点，将右节点连接全部断开，并设为根节点\n                if (removeNode == this.root){\n                    this.root = removeNode.right;\n                    this.root.parent = null;\n                    removeNode.right = null;\n                    count--;\n                    return;\n                }\n                if (isLeft(removeNode)) {\n                    //删除节点 是 左节点，将其右节点设为其 父节点的左节点\n                    removeNode.parent.left = removeNode.right;\n                } else {\n                    removeNode.parent.right = removeNode.right;\n                }\n                //删除节点的右节点的父节点 设为删除节点的父节点\n                removeNode.right.parent = removeNode.parent;\n                removeNode.parent = null;\n                removeNode.right = null;\n            }//3: 两边都有节点，则将其右节点中最左边的节点找到，改变其指向\n            else {\n                Node moveNode = removeNode.right; //移动的节点\n                /*\n                现在还有左边的节点，一直向左找（找到删除节点右边最小的节点）\n                也可以找删除节点左边最大的节点（左节点的最后一个右节点）\n                 */\n                while (moveNode.left != null) {\n                    moveNode = moveNode.left;\n                }\n                //移动节点不是删除节点的右节点\n                if (moveNode != removeNode.right) {\n                    //移动节点无子节点，直接断开将其父节点的左节点置空\n                    if (moveNode.right == null) {\n                        moveNode.parent.left = null;\n                    }//移动节点有右节点，将其右节点连接到其父节点的左节点代替此节点\n                    else {\n                        moveNode.parent.left = moveNode.right;\n                        moveNode.right.parent = moveNode.parent;\n                    }\n                    //建立移动节点和删除节点右节点的连接\n                    moveNode.right = removeNode.right;\n                    removeNode.right.parent = moveNode;\n                }\n                /*\n                若移动节点刚好是删除节点的右节点，则移动节点的右节点链接保持不变\n                同时移动节点就是删除节点的右节点，所以对删除节点的右节点不再操作\n                 */\n                //建立移动节点和删除节点左节点的连接\n                moveNode.left = removeNode.left;\n                removeNode.left.parent = moveNode;\n                //若被删节点不是根节点，将删除节点的父节点设为移动节点的父节点\n                if (removeNode.parent != null) {\n                    moveNode.parent = removeNode.parent;\n                    //删除节点是左节点，将其父节点的左节点设为移动节点\n                    if (isLeft(removeNode)) {\n                        removeNode.parent.left = moveNode;\n                    } else {\n                        removeNode.parent.right = moveNode;\n                    }\n                } else {\n                    moveNode.parent = null;\n                    this.root = moveNode;\n                }\n            }\n            this.count--;//删除完成后数据数量 -1\n        }\n    }\n}\n\n\n//实现 Comparable 接口，系统可实现自动排序\nclass Person implements Comparable<Person> {\n    private int age;\n\n    public Person(int age) {\n        this.age = age;\n    }\n\n    //重写 compareTo 方法，定义排序规则\n    @Override\n    public int compareTo(Person per) {\n        //当前数据比传入的对象小返回负数，如果大于返回整数，如果等于返回0\n        return this.age - per.age; //排序规则，按年龄升序排列\n    }\n\n    @Override\n    public String toString() {\n        return \"年龄: \" + this.age;\n    }\n}\n```\n\n### 红黑树\n\n红黑树本质是一种二叉查找树\n\n- 本质上是在节点上追加了一个表示颜色的操作信息\n- 同时有一定规则使得红黑树保证了一种平衡\n- 插入、删除、查找的最坏时间复杂度都为 log(n)\n\n红黑树在 1972 年由 Rudolf Bayer 发明，当时被称为平衡二叉B树，在 1978 年被 Leo J.Guibas 和 Robert修改为如今的 红黑树\n\n![红黑树基本结构](/resources/Images/c9ef82b526ce47ed8bee92d8d912d9b6.png)\n\n#### 规则\n\n1. 每个节点都是黑色 或 红色\n\n   - Node 节点的颜色也可以使用 True 或 False，并非必须使用枚举类\n\n2. 根节点必须是黑色\n\n3. 每个叶子节点是黑色（叶子节点：红黑树结构最底部的节点）\n\n   - Java实现的红黑树使用 null 代表空节点\n\n   - 因此遍历红黑树看不到黑色的叶子节点，反而每个叶子节点都是红色的\n\n4. 若一个节点是红色的，则它的子节点必须是黑色\n\n   - 每个根到结点的路径不会有两个连续的红色节点，但黑色节点可以连续\n\n   - 若给定黑色节点个数 Ｎ\n     - 最短路径是连续 N 个黑色，树的高度 N - 1\n     - 最长路径红黑节点相间，树高 2(N - 1)\n\n5. 一个节点到该节点的子孙节点所有路径包含相同的黑节点数量\n\n   - 成为红黑树的主要条件，后序的插入、删除都是为遵守这个规定\n\n进行红黑树处理的时候为方便操作会将 新节点使用红色 描述\n\n------\n\n不允许 红-红 连接，但允许 黑-黑 连接\n\n- 主要利用红色节点与黑色节点实现均衡的控制\n- 红黑树结构就是为了可以进行左、右旋的控制，保证树的平衡\n- 对于平衡性还需要考虑数据增加和删除的平衡\n  - 增、删都要对树的进行平衡修复\n  - 平衡修复目的\n    - 保证树结构中黑色节点的数量平衡\n    - 结构平衡才有可能达到 long(n) 的执行性能\n  - 但修复过程一方面是红黑的处理，另一方面是黑色节点的保存层次\n\n#### 数据插入平衡修复\n\n为方便操作默认插入红色节点\n\n- 第一个数据插入时由于原树为空，所以会违反红-黑树规则二\n  - 将根节点涂黑即可\n- 若插入节点的父节点是黑色，不会违反规则，无需额外操作\n- 插入节点的父节点是红色需要进行修复（变色、左右旋）\n\n1. **数据插入平衡处理规则1**\n\n   - 插入节点的父节点和其叔叔节点均为红色\n\n     - 将插入节点的父节点和叔叔节点涂黑\n     - 将父节点的父节点涂红\n\n     ![平衡处理规则1](/resources/Images/6fa5b0d7acf84d309346982634d1db9e.png)\n\n2. **数据插入平衡处理规则2**\n\n   - 插入节点的父节点是红色，叔叔节点是黑色；且插入节点是其父节点的左节点\n\n     - 将插入结点的父节点与祖父节点颜色互换（图中50应变为红色）\n     - 随后右旋处理，以父节点为根（此段连接中的临时根节点）\n\n     ![平衡处理规则2](/resources/Images/8ece4023d98249fead2bc0bf0edb8916.png)\n\n3. **数据插入平衡处理规则3**\n\n   - 插入节点的父节点是红色，叔叔节点是黑色；且插入节点是其父节点的右节点\n\n     - 将插入节点和其父节点进行左旋\n       - 此时符合处理规则2\n       - 将插入结点与祖父节点颜色互换\n       - 随后右旋处理，以插入节点为根（此段连接中的临时根节点）\n\n     ![平衡处理规则3](/resources/Images/8a680d838f504b1f9bdf9b5d4551efc9.png)\n\n     ![处理](/resources/Images/b55648923b75432dad29073a6d9087c6.png)\n\n##### 插入操作分析\n\n------\n\n在红黑树修复中，需要根据\n\n- 插入节点的颜色\n- 父节点的颜色\n- 叔叔节点的颜色\n\n进行判断是否需要修复\n\n------\n\n- 祖父节点：父节点的父节点\n- 叔叔节点：祖父节点的另一个子节点\n- 默认插入红色节点\n\n即修复逻辑：\n\n- 父节点是红色，叔叔节点是红色\n  - 父节点、叔叔节点变黑；祖父节点变红\n  - 祖父节点不为根节点，否则需要额外操作\n- 父节点是红色，叔叔节点是黑色\n  - 插入节点是左节点\n    - 将父节点和祖父节点颜色交换\n    - 以父节点为根进行右旋\n  - 插入节点是右节点\n    - 以插入节点为根进行左旋，此时符合上一种情况\n      - 此时插入节点在原父节点的位置\n    - 将插入节点和祖父节点交换颜色\n    - 以插入节点为根进行右旋\n\n#### 数据删除平衡修复\n\n- 先根据二叉树数据删除操作进行删除处理\n  - 当前节点：删除节点之后补在原位置的节点\n  - 兄弟节点：父节点的另一个节点\n\n##### 修复规则\n\n- 当前节点是黑色的根节点\n  - 无需处理，未破坏树的平衡性\n- 需要变色或旋转来修复\n  - 当前节点是红色\n    - 则移走的后继节点是黑色，将当前节点涂黑即可\n  - 当前节点是黑色，兄弟节点是红色\n  - 当前节点和兄弟节点是黑色\n    - 且兄弟节点的两个节点都是黑色\n    - 或兄弟节点左节点红色，右节点黑色\n    - 或兄弟节点右节点红色\n\n1. **修复规则1**\n\n   - 当前节点黑色，兄弟节点红色\n\n     - 此时父节点和兄弟节点的子节点肯定是黑色\n     - 将当前节点的父节点变红，兄弟节点变黑\n     - 将父节点作为支点左旋（不为根节点无需旋转）\n\n     ![修复规则1](/resources/Images/image-20220101230435034.png)\n\n2. **修复规则2**\n\n   - 当前节点和兄弟节点是黑色；兄弟节点的子节点都是黑色\n\n     - 将兄弟节点变红，不进行旋转\n     - 然后进行规则 3（或 4），以兄弟节点为支点进行右旋（或父节点为支点左旋）\n\n     ![image-20220101230316936](/resources/Images/image-20220101230316936.png)\n\n3. **修复规则3**\n\n   - 当前节点和兄弟节点是黑色；兄弟节点左节点是红色，右节点是黑色\n\n     - 将兄弟节点变红，兄弟节点左节点变黑\n     - 以兄弟节点为支点进行右旋\n\n     ![修复规则3](/resources/Images/image-20220101231121725.png)\n\n4. **修复规则4**\n\n   - 当前节点和兄弟节点为黑色；兄弟节点右节点红色（左节点任意）\n\n     - 将兄弟节点变成和父节点相同颜色，父节点变黑，兄弟节点右节点变黑\n     - 以父节点为支点左旋\n\n     ![修复规则4](/resources/Images/image-20220101234507289.png)\n\n', 'Java', '二叉树 Java', '1', 83, '1', '0', '2022-07-09 21:43:45', '2022-07-17 17:54:13', 0);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `cate_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `cate_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '类别名',
  `cate_weights` int(11) UNSIGNED NOT NULL DEFAULT 1 COMMENT '类别权重，默认 1',
  `create_time` datetime NOT NULL,
  PRIMARY KEY (`cate_id`) USING BTREE,
  UNIQUE INDEX `cate_name`(`cate_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (2, 'Java', 4, '2022-04-19 23:20:00');
INSERT INTO `category` VALUES (3, 'JavaScript', 1, '2022-04-20 21:28:31');
INSERT INTO `category` VALUES (4, '随笔', 0, '2022-04-22 23:00:56');
INSERT INTO `category` VALUES (6, '预习', 1, '2022-04-25 18:47:02');
INSERT INTO `category` VALUES (7, '正则', 1, '2022-05-15 21:31:09');
INSERT INTO `category` VALUES (8, 'HTML', 1, '2022-05-16 17:18:56');
INSERT INTO `category` VALUES (9, 'About', 1, '2022-05-25 20:06:36');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `comment_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '评论 id',
  `blog_id` int(11) UNSIGNED NOT NULL COMMENT '被评论博客 id',
  `commentator` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论人',
  `tel_num` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论人联系方式',
  `comment_time` datetime NOT NULL COMMENT '评论时间',
  `comment_body` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论内容',
  `deleted` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '评论是否被删除',
  `reply` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '回复',
  `reply_time` datetime NULL DEFAULT NULL COMMENT '回复时间',
  PRIMARY KEY (`comment_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 20 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, 13, '二狗', '12345678910', '2022-06-11 16:28:44', '帅哥你好', '1', '大家都是帅哥，你好啊', '2022-06-11 22:06:27');
INSERT INTO `comment` VALUES (2, 13, '小二狗', '12345678901', '2022-06-11 20:35:04', '帅哥你好', '0', '大家都是帅哥', '2022-07-01 22:27:54');
INSERT INTO `comment` VALUES (3, 11, '游客', '12345678901', '2022-06-11 22:25:28', '很不错', '0', '帅哥必备\n', '2022-07-01 22:30:06');
INSERT INTO `comment` VALUES (4, 13, '帅哥', '11223344551', '2022-06-12 22:57:05', '看我名字就是到我们是同种类型 || -_- ||', '0', '同是帅哥，惺惺相惜', '2022-06-20 21:59:46');
INSERT INTO `comment` VALUES (5, 9, '帅哥', '11122233311', '2022-06-18 23:05:41', '同是帅哥沦落人', '0', NULL, NULL);
INSERT INTO `comment` VALUES (6, 12, '帅哥', '12345678899', '2022-06-19 14:47:12', '英雄所见略同', '0', NULL, NULL);
INSERT INTO `comment` VALUES (7, 10, '十八', '12345678901', '2022-07-16 23:39:20', '不错不错', '0', NULL, NULL);
INSERT INTO `comment` VALUES (8, 13, '十八', '12345678909', '2022-07-16 23:44:02', '帅哥帅哥', '0', '帅哥帅哥', '2022-07-22 22:49:28');
INSERT INTO `comment` VALUES (9, 13, '帅哥', '12345678809', '2022-07-17 16:33:37', '帅帅帅', '0', 'nice nice nice', '2022-07-22 22:49:39');
INSERT INTO `comment` VALUES (10, 13, '努力', '11111122222', '2022-07-17 16:33:57', '一起加油', '0', '一起努力了', '2022-07-22 22:50:33');
INSERT INTO `comment` VALUES (11, 9, '牡蛎', '12345654321', '2022-07-17 16:35:25', '很不错', '0', NULL, NULL);
INSERT INTO `comment` VALUES (12, 12, '小小小怪', '11111222233', '2022-07-18 20:58:29', '小小小怪下士到', '0', NULL, NULL);
INSERT INTO `comment` VALUES (13, 10, '小小怪下士', '11122233344', '2022-07-18 21:30:33', '大大怪将军在哪', '0', NULL, NULL);
INSERT INTO `comment` VALUES (14, 13, 'xiaoxiao', '12345676890', '2022-07-18 22:07:34', '11122233', '1', NULL, NULL);
INSERT INTO `comment` VALUES (15, 13, 'qqq', '12345678901', '2022-07-18 22:18:27', 'thank you', '1', NULL, NULL);
INSERT INTO `comment` VALUES (16, 13, 'qqww', '12365498701', '2022-07-18 22:33:40', '酷酷酷', '1', '英雄所见略同', '2022-07-22 22:49:06');
INSERT INTO `comment` VALUES (17, 13, 'wwqq', '12365498710', '2022-07-18 22:34:09', '帅帅帅', '1', '彼此彼此', '2022-07-22 22:48:47');
INSERT INTO `comment` VALUES (18, 13, '小小小', '12233344411', '2022-07-21 23:37:09', '小小小小怪', '0', '大大大大怪将军在此', '2022-07-21 23:41:41');
INSERT INTO `comment` VALUES (19, 12, '大大大', '11112222333', '2022-07-21 23:37:40', '大大大大怪将军', '0', NULL, NULL);

-- ----------------------------
-- Table structure for commentdata
-- ----------------------------
DROP TABLE IF EXISTS `commentdata`;
CREATE TABLE `commentdata`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `blogId` int(11) NOT NULL COMMENT '博客id',
  `blogTitle` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '博客标题',
  `num` int(11) NOT NULL COMMENT '该博客当前未读评论数',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `blogId`(`blogId`) USING BTREE,
  UNIQUE INDEX `blogTitle`(`blogTitle`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of commentdata
-- ----------------------------

-- ----------------------------
-- Table structure for config
-- ----------------------------
DROP TABLE IF EXISTS `config`;
CREATE TABLE `config`  (
  `config_id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '配置id',
  `config_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '配置名',
  `config_value` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '配置值',
  `update_time` datetime NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`config_id`) USING BTREE,
  INDEX `config_name`(`config_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of config
-- ----------------------------
INSERT INTO `config` VALUES (1, 'avatar', '/avatar/img.png', '2022-07-14 21:20:25');
INSERT INTO `config` VALUES (2, 'avatar', '/avatar/shiba.png', '2022-07-14 21:25:14');
INSERT INTO `config` VALUES (3, 'avatar', '/avatar/220715-225959-1657897199390.jpg', NULL);
INSERT INTO `config` VALUES (4, 'avatar', '/avatar/220716-215201-1657979521605.jpg', NULL);
INSERT INTO `config` VALUES (5, 'avatar', '/avatar/220716-221053-1657980653186.jpg', NULL);

-- ----------------------------
-- Table structure for link
-- ----------------------------
DROP TABLE IF EXISTS `link`;
CREATE TABLE `link`  (
  `link_id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '友链 id',
  `link_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '友链类型，0-友链 1-推荐',
  `link_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '站点名',
  `link_url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '站点描述',
  `link_description` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '链接地址',
  `link_weights` int(11) NOT NULL DEFAULT 0 COMMENT '链接权重，排序占比',
  `create_time` datetime NOT NULL COMMENT '添加时间',
  `deleted` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '是否删除，0-正常 1-删除',
  PRIMARY KEY (`link_id`) USING BTREE,
  UNIQUE INDEX `link_url`(`link_url`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of link
-- ----------------------------
INSERT INTO `link` VALUES (1, '1', ' Learn Git Branching', 'https://oschina.gitee.io/learn-git-branching/', '快速学习git操作的推荐网站', 3, '2022-06-25 21:47:27', '0');
INSERT INTO `link` VALUES (2, '1', 'layui', ' https://www.layuiweb.com/doc/index.html', 'layui官方文档', 5, '2022-06-25 21:58:25', '0');
INSERT INTO `link` VALUES (3, '1', 'CSDN', 'https://www.csdn.net/', '专业开发者社区', 3, '2022-06-26 16:49:07', '0');
INSERT INTO `link` VALUES (4, '0', '笔趣阁', 'http://www.gebiqu.com/', '学习之余进行放松', 1, '2022-06-26 17:01:58', '0');
INSERT INTO `link` VALUES (5, '1', '百度', 'https://www.baidu.com/', '百度一下，你就知道', 3, '2022-07-05 21:57:21', '0');
INSERT INTO `link` VALUES (6, '1', 'BiliBili', 'https://www.bilibili.com/', '学习资源网站', 5, '2022-07-17 18:12:01', '0');
INSERT INTO `link` VALUES (7, '0', 'iodraw', 'https://www.iodraw.com/diagram/', '免费做图网站', 2, '2022-07-17 18:12:53', '0');
INSERT INTO `link` VALUES (8, '1', 'LeetCode', 'https://leetcode.cn/', '算法刷题', 3, '2022-07-17 18:13:34', '0');
INSERT INTO `link` VALUES (9, '0', 'Java全栈学习网站', 'https://www.pdai.tech/md/outline/x-outline.html', 'Java全栈学习知识体系网站', 3, '2022-07-17 18:17:09', '0');
INSERT INTO `link` VALUES (10, '1', '牛客网', 'https://www.nowcoder.com/', '找工作神器，刷题面试，投递简历', 6, '2022-07-22 22:53:49', '0');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `tag_id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '标签id',
  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '标签名',
  `tag_weights` int(11) UNSIGNED NOT NULL DEFAULT 1 COMMENT '标签权重，排序使用',
  PRIMARY KEY (`tag_id`) USING BTREE,
  UNIQUE INDEX `tag_name`(`tag_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 30 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (5, '随笔', 0);
INSERT INTO `tag` VALUES (6, '基础', 7);
INSERT INTO `tag` VALUES (13, 'Magaic', 0);
INSERT INTO `tag` VALUES (14, '练习', 0);
INSERT INTO `tag` VALUES (16, '简单', 0);
INSERT INTO `tag` VALUES (17, '预习', 2);
INSERT INTO `tag` VALUES (18, 'JS', 1);
INSERT INTO `tag` VALUES (19, '学习', 4);
INSERT INTO `tag` VALUES (20, '小说', 0);
INSERT INTO `tag` VALUES (21, 'Novel', 0);
INSERT INTO `tag` VALUES (22, 'Java', 2);
INSERT INTO `tag` VALUES (23, '面向对象', 1);
INSERT INTO `tag` VALUES (24, '正则', 1);
INSERT INTO `tag` VALUES (25, 'html', 1);
INSERT INTO `tag` VALUES (26, 'About_Me', 1);
INSERT INTO `tag` VALUES (27, '开始', 1);
INSERT INTO `tag` VALUES (28, '反射', 1);
INSERT INTO `tag` VALUES (29, '二叉树', 1);

SET FOREIGN_KEY_CHECKS = 1;
